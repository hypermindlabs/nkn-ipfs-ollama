<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>NKN Client — LLM Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">

  <meta name="theme-color" content="#000" />
  <!-- NKN SDK -->
  <script src="https://unpkg.com/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
  <script>
    /* 1) Harden RTCPeerConnection.setRemoteDescription against closed-state races */
    (() => {
      const RTCPeer =
        window.RTCPeerConnection ||
        window.webkitRTCPeerConnection ||
        window.mozRTCPeerConnection;

      if (!RTCPeer || RTCPeer.prototype.__patchedRemoteDesc) return;

      const origSRD = RTCPeer.prototype.setRemoteDescription;

      RTCPeer.prototype.setRemoteDescription = function (...args) {
        if (this.signalingState === 'closed') {
          // Swallow “InvalidStateError: signalingState is 'closed'”
          return Promise.resolve();
        }
        try {
          const p = origSRD.apply(this, args);
          return Promise.resolve(p).catch((err) => {
            const name = err && err.name;
            const msg = (err && (err.message || String(err))) || '';
            if (name === 'InvalidStateError' || /signalingState.*closed/i.test(msg)) {
              // Treat as benign; connection already torn down
              return;
            }
            throw err;
          });
        } catch (err) {
          const name = err && err.name;
          const msg = (err && (err.message || String(err))) || '';
          if (name === 'InvalidStateError' || /signalingState.*closed/i.test(msg)) {
            return Promise.resolve();
          }
          throw err;
        }
      };

      RTCPeer.prototype.__patchedRemoteDesc = true;
    })();
  </script>

  <script>
    /* 2) Mute noisy transient/unrecoverable rejections from the NKN stack */
    window.addEventListener('unhandledrejection', (e) => {
      const r = e && e.reason;
      const name = r && r.name;
      const msg = String((r && (r.message || r)) || e);

      // Already had some filters — extend them to cover WebRTC/WebSocket flaps
      const shouldSuppress =
        name === 'InvalidStateError' ||
        /setRemoteDescription/i.test(msg) ||
        /RTC(DataChannel|PeerConnection)/i.test(msg) ||
        /WebSocket unexpectedly closed/i.test(msg) ||
        /Message timeout/i.test(msg) ||
        /ConnectToNodeTimeoutError/i.test(msg);

      if (shouldSuppress) {
        e.preventDefault();
      }
    });
  </script>

  <!-- Import map (kept as requested) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
    }
  }
  </script>

  <!-- QR, Markdown, and Syntax Highlighting -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs-themes@1.0.0/tomorrow-night-blue.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Instrument+Sans:ital,wght@0,400..700;1,400..700&display=swap');

    :root {
      --bg: #000;
      --panel: #0a0a0a;
      --line: #141414;
      --fg: #fff;
      --muted: #bfbfbf;
      --accent: #fff;
      --pad: 12px;
      --radius: 14px;
      --shadow: 0 12px 30px rgba(0, 0, 0, .45);
    }

    * {
      box-sizing: border-box;
      transition: all 0.2s ease;
      scrollbar-width: none;
      /* Makes the scrollbar thinner */

    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: "Instrument Sans", sans-serif;
      touch-action: manipulation;
      user-select: none;
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 260px 1fr;
      grid-template-areas: "top top" "left main";
      height: 100%
    }

    input:focus,
    textarea:focus {
      outline: none;
    }

    think {
      opacity: 0.5;
      padding: 0.25rem 0.5rem;
      background: #212121;
      display: block;
      border-radius: 6px;
      border: 1px solid #333;
    }

    a {
      color: #00ffff;
      text-decoration: unset;
      font-weight: bold;
    }

    header {
      max-height: 400px;
      grid-area: top;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      flex-flow: wrap;
      gap: 10px;
      padding: 10px var(--pad);
      background: #000;
      position: sticky;
      top: 0;
      z-index: 20;
      border-bottom: 1px solid var(--line);

    }

    .brand {
      font-weight: 700;
      letter-spacing: .3px
    }

    .spacer {
      flex: 1
    }

    .topbar-select {
      font-size: 1rem;
      appearance: none;
      background: #000;
      font-weight: bold;
      border: 1px solid #2a2a2a;
      color: var(--fg);
      padding: 8px 10px;
      border-radius: 8px;
      height: 38px;
      max-width: calc(100vw - 168px);
    }

    .topbar-select option {
      font-size: 1rem;
      text-transform: capitalize;

    }

    .chip {
      padding: 8px 10px;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      color: #eaeaea;
      background: #0a0a0a;
      display: flex;
      gap: 0.5rem;
      height: 38px;
      font-weight: bold;
      text-transform: capitalize;
    }

    .chip b {
      margin: auto;
      font-size: 0.8rem;
    }

    .chiprow {
      display: flex;
      flex-flow: row;
      gap: 1rem;
      margin-bottom: 1rem;
      line-height: 1;

    }

    .gear {
      display: flex;
      flex-flow: row;
      justify-content: center;
      min-width: 34px;
      min-height: 34px;
      cursor: pointer;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 10px 10px;
      font-size: 14px;
      line-height: 1;
      background: #0a0a0a;
      color: white;
    }

    .gear:active {
      transform: scale(1.02)
    }

    .col-left {
      grid-area: left;
      border-right: 1px solid #141414;
      background: #050505;
      display: flex;
      flex-direction: column;
      min-width: 0;
      z-index: 21;

    }

    .left-head {
      padding: 10px var(--pad);
      border-bottom: 1px solid #141414;
      display: flex;
      align-items: center;
      gap: 8px
    }

    .sessions {
      flex: 1;
      overflow: auto;
      padding: 8px
    }

    .session {
      position: relative;
      padding: 10px;
      border: 1px solid #1a1a1a;
      border-radius: 8px;
      margin-bottom: 8px;
      background: #0a0a0a;
      cursor: pointer
    }

    .session.active {
      border-color: #fff
    }

    .session .title {
      font-weight: 600;
      padding-right: 28px
    }

    .session small {
      color: #cfcfcf;
      opacity: .8
    }

    .session .del {
      position: absolute;
      top: 0px;
      right: 0px;
      height: 32px;
      width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      cursor: pointer;
      border: unset;
      background: transparent;
    }

    .session .del:hover {}

    .col-main {
      position: relative;
      box-sizing: border-box;
      grid-area: main;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      min-width: 0
    }

    .col-main::before {
      content: "";
      position: absolute;
      top: 0px;
      z-index: 10;
      height: 10rem;
      max-height: 10%;
      pointer-events: none;
      mask: linear-gradient(black, #000e, #000a, #0005, transparent, transparent, transparent);
      backdrop-filter: blur(10px);
      width: 100%;
    }

    .sysedit {
      border-bottom: 1px solid #141414;
      background: #050505;
      box-sizing: border-box;
      height: auto;
      width: 100%;
      line-height: 1;
      z-index: 2;
      position: absolute;
      top: 0px;

    }

    .sysedit label {
      display: block;
      font-size: 12px;
      color: #cfcfcf;
      margin-bottom: 6px;
    }

    .sysinput {
      width: 100%;
      min-height: 64px;
      resize: vertical;
      background: #000;
      border: 1px solid #2a2a2a;
      color: #fff5;
      border-radius: 12px;
      padding: 10px;
      field-sizing: content;
      max-height: calc(80vh - 80px);

    }

    .sysinput:focus {
      outline: none;
      border-color: #fff;
      color: #fff
    }

    .chat {
      position: relative;
      display: block;
      height: 100%;
      flex: 1;
      overflow: auto;
      padding: 16px;
      max-height: calc(100vh - 124px);
      scroll-behavior: smooth
    }

    .msg {
      max-width: 900px;
      display: flex;
      flex-flow: column;
      margin: 0 auto 14px auto;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid #1a1a1a
    }

    .user {
      background: #0a0a0a
    }

    .assistant {
      background: #0a0a0a;
      border-color: #2a2a2a
    }

    .meta {
      display: flex;
      gap: 10px;
      align-items: center;
      color: #bfbfbf;
      font-size: 12px;
      margin-bottom: 6px
    }

    .content {
      word-wrap: break-word
    }

    .content p {
      margin: .5em 0
    }

    .content img {
      max-width: 100%;
      border-radius: 8px
    }

    .content code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      background: #0b0b0b;
      border: 1px solid #2a2a2a;
      border-radius: 6px;
      padding: .2em .35em
    }

    .content pre {
      background: #0b0b0b;
      border: 1px solid #2a2a2a;
      border-radius: 12px;
      padding: 12px;
      overflow: auto
    }

    .content pre code {
      background: transparent;
      border: none;
      padding: 0
    }

    .content blockquote {
      border-left: 3px solid #2a2a2a;
      margin: 8px 0;
      padding: 6px 10px;
      color: #cfd8dc;
      background: #071018;
      border-radius: 8px
    }

    .content ul,
    .content ol {
      padding-left: 1.4em
    }

    .composer {
      display: flex;
      gap: 10px;
      padding: 12px;
      border-top: 1px solid #141414;
      background: #050505
    }

    .input {
      flex: 1;
      resize: none;
      height: 40px;
      border: unset;
      background: #000;
      color: var(--fg);
      border-radius: 12px;
      padding: 12px
    }


    #systemToggleBtn {
      color: #2a2a2a;
      border-color: #2a2a2a;
    }

    .btnSq {
      aspect-ratio: 1 / 1;

    }

    .btn {
      background-color: black;
      border: 1px solid #fff;
      color: #fff;
      padding: 8px 8px;
      line-height: 1;
      display: flex;
      flex-flow: column;
      justify-content: center;
      border-radius: 8px;
      cursor: pointer
    }

    .btn:hover {
      background-color: white;
      border: 1px solid #fff;
      color: #000;
      padding: 8px 8px;
      line-height: 1;
      display: flex;
      flex-flow: column;
      justify-content: center;
      cursor: pointer
    }

    .btn:hover>svg path {
      stroke: black;
    }

    .btn:active {
      transform: translateY(1px)
    }

    #connText {
      display: flex;
      flex-flow: column;
      justify-content: center;
      ;
    }

    @keyframes dotdotdot {
      0% {
        content: '.'
      }

      33% {
        content: '..'
      }

      66% {
        content: '...'
      }

      100% {
        content: ''
      }

    }

    .dot {
      animation: dotdotdot 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg)
      }

      100% {
        transform: rotate(360deg)
      }

    }

    @keyframes bump {
      0% {
        transform: translateX(0px)
      }

      40% {
        transform: translateX(-3px)rotate(-5deg)
      }

      60% {
        transform: translateX(3px)rotate(5deg)
      }

      100% {
        transform: translateX(0px)rotate(0deg)
      }

    }

    /* jump-to-bottom button */
    #scrollToBottomBtn {
      position: absolute;
      right: 16px;
      bottom: 88px;
      /* sits above the composer */
      display: none;
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 999px;
      padding: 10px;
      box-shadow: var(--shadow);
      cursor: pointer;
      z-index: 12;
    }

    #scrollToBottomBtn:hover {
      transform: translateY(-1px);
    }

    #scrollToBottomBtn:active {
      transform: translateY(0);
    }

    #modelCaps {
      margin-right: auto;
      display: none;
    }

    .thumb {
      position: relative;
      width: 54px;
      height: 54px;
      border-radius: 8px;
      border: 1px solid #2a2a2a;
      overflow: hidden;
      margin-right: 6px;
    }

    .thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .thumb .x {
      position: absolute;
      top: -6px;
      right: -6px;
      background: #111;
      border: 1px solid #2a2a2a;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      font-size: 12px;
      line-height: 16px;
      text-align: center;
      cursor: pointer;
    }

    #sendBtn {
      display: flex;
    }

    .sendButton {
      background: transparent;
      border: unset;
      cursor: pointer;
      flex-flow: column;
      justify-content: center;
    }

    .sendButton:hover {
      animation: bump 0.3s ease-in-out;
    }

    .row {
      display: flex;
      flex-flow: row;
      gap: 8px;
    }

    .between {
      justify-content: space-between;
    }

    .muted {
      color: #cfcfcf;
      opacity: .8
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      backdrop-filter: blur(10px);
    }

    .overlaySys {
      position: fixed;
      display: flex;
      inset: 0;
      align-items: center;
      justify-content: center;
      z-index: 50;
      backdrop-filter: blur(10px);
    }

    .modal {
      width: min(560px, 92vw);
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 14px
    }

    .modal h3 {
      margin: .2rem 0 .8rem 0
    }

    .modal>.row {
      display: flex;
      justify-content: space-between;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px
    }

    .text {
      background: #000;
      border: 1px solid #2a2a2a;
      color: #fff;
      padding: 10px;
      border-radius: 8px
    }

    .num {
      background: #000;
      border: 1px solid #2a2a2a;
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      width: 120px
    }

    .chkrow {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 6px
    }

    .modal .row {
      margin-top: 10px
    }

    /* ── Connection status dot in header ───────────────────────────────────── */
    .conn-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid #2a2a2a;
      display: none;
    }

    .conn-blue {
      background: #3b82f6;
    }

    /* connecting / reconnecting */
    .conn-green {
      background: #22c55e;
    }

    /* connected */
    .conn-red {
      background: #ef4444;
    }

    /* error / disconnected */

    .hide {
      display: none !important;
    }

    /* helper to hide model select until ready */
    #toggleSidebar {
      display: none;
    }

    .backdropModal {
      height: 100vh;
      width: 100vw;
      position: fixed;
      top: 0px;
      left: 0px;
      z-index: -1;
    }

    .sysBackdrop {
      height: 100vh;
      width: 100vw;
      position: fixed;
      top: 0px;
      left: 0px;
      z-index: -1;
    }


    #systemActions .btnSq {
      width: 36px;
      height: 36px;
      padding: 0;
      font-weight: 700;
      display: flex;
      flex-flow: row !important;
      justify-content: center;
    }

    #systemActions .btnSq>svg {
      margin: auto;
    }

    .btn.toggled {
      border-color: #ffffff;
      box-shadow: 0 0 0 1px #ffffff inset;
    }


    @media (max-width: 900px) {
      #toggleSidebar {
        display: flex;
      }

      .app {
        grid-template-columns: 1fr;
        grid-template-areas: "top" "main"
      }

      .col-left {
        display: flex;
        position: fixed;
        width: 50%;
        z-index: 21;
        left: -50%;
        top: 0px;
        bottom: 0px;
      }

      #backdrop {
        height: 100vh;
        position: absolute;
        bottom: 0px;
        width: 100vw;
        left: -100%;
        backdrop-filter: blur(10px);
        z-index: -1;
      }

      #modelCaps {
        display: none !important;
      }
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <button class="gear" id="toggleSidebar">
        <!-- (icon unchanged) -->
        <svg width="16px" height="16px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M11 5V19M6 8H8M6 11H8M6 14H8M6.2 19H17.8C18.9201 19 19.4802 19 19.908 18.782C20.2843 18.5903 20.5903 18.2843 20.782 17.908C21 17.4802 21 16.9201 21 15.8V8.2C21 7.0799 21 6.51984 20.782 6.09202C20.5903 5.71569 20.2843 5.40973 19.908 5.21799C19.4802 5 18.9201 5 17.8 5H6.2C5.0799 5 4.51984 5 4.09202 5.21799C3.71569 5.40973 3.40973 5.71569 3.21799 6.09202C3 6.51984 3 7.07989 3 8.2V15.8C3 16.9201 3 17.4802 3.21799 17.908C3.40973 18.2843 3.71569 18.5903 4.09202 18.782C4.51984 19 5.07989 19 6.2 19Z"
            stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
      </button>

      <!-- NEW: connection status (dot + label). The model select will be injected next to this. -->
      <div id="statusRow" class="row">
        <span id="connDot" class="conn-dot" aria-hidden="true"></span>
        <span id="connText" class="muted"></span>
      </div>

      <!-- The select stays in DOM; we will move it next to #statusRow and hide it until models are ready -->
      <select id="modelSelect" class="topbar-select" title="Available models" disabled>
        <option style="text-align:center;">Loading Models</option>
      </select>

      <div id="modelCaps" class="row"></div>

      <div id="netStats" class="row" style="gap:8px;">
        <div id="peers" class="chip" title="Active clients the hub reports">Peers</div>
        <div id="latent" class="chip" title="Round‑trip latency to the hub">Latency</div>
      </div>

      <button id="systemToggleBtn" class="gear btnSq"><svg width="16px" height="16px" viewBox="0 0 24 24" fill="none"
          xmlns="http://www.w3.org/2000/svg">
          <path
            d="M3 7.2C3 6.07989 3 5.51984 3.21799 5.09202C3.40973 4.71569 3.71569 4.40973 4.09202 4.21799C4.51984 4 5.0799 4 6.2 4H17.8C18.9201 4 19.4802 4 19.908 4.21799C20.2843 4.40973 20.5903 4.71569 20.782 5.09202C21 5.51984 21 6.0799 21 7.2V20L17.6757 18.3378C17.4237 18.2118 17.2977 18.1488 17.1656 18.1044C17.0484 18.065 16.9277 18.0365 16.8052 18.0193C16.6672 18 16.5263 18 16.2446 18H6.2C5.07989 18 4.51984 18 4.09202 17.782C3.71569 17.5903 3.40973 17.2843 3.21799 16.908C3 16.4802 3 15.9201 3 14.8V7.2Z"
            stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
          <path
            d="M8.40499 12.675C8.44031 12.4984 8.45796 12.4101 8.49025 12.3278C8.51891 12.2547 8.55608 12.1853 8.60098 12.1209C8.65157 12.0484 8.71523 11.9847 8.84255 11.8574L13 7.69995C13.5523 7.14767 14.4477 7.14767 15 7.69995C15.5523 8.25224 15.5523 9.14767 15 9.69995L10.8426 13.8574C10.7152 13.9847 10.6516 14.0484 10.579 14.099C10.5147 14.1439 10.4452 14.181 10.3721 14.2097C10.2898 14.242 10.2015 14.2596 10.025 14.295L8 14.7L8.40499 12.675Z"
            stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg></button>



      <button id="settingsBtn" class="gear btnSq" aria-label="Settings">
        <!-- (icon unchanged) -->
        <svg width="16px" height="16px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M12 3L14.0357 8.16153C14.2236 8.63799 14.3175 8.87622 14.4614 9.0771C14.5889 9.25516 14.7448 9.41106 14.9229 9.53859C15.1238 9.68245 15.362 9.77641 15.8385 9.96432L21 12L15.8385 14.0357C15.362 14.2236 15.1238 14.3175 14.9229 14.4614C14.7448 14.5889 14.5889 14.7448 14.4614 14.9229C14.3175 15.1238 14.2236 15.362 14.0357 15.8385L12 21L9.96432 15.8385C9.77641 15.362 9.68245 15.1238 9.53859 14.9229C9.41106 14.7448 9.25516 14.5889 9.0771 14.4614C8.87622 14.3175 8.63799 14.2236 8.16153 14.0357L3 12L8.16153 9.96432C8.63799 9.77641 8.87622 9.68245 9.0771 9.53859C9.25516 9.41106 9.41106 9.25516 9.53859 9.0771C9.68245 8.87622 9.77641 8.63799 9.96432 8.16153L12 3Z"
            stroke="#ffffff" stroke-width="2" stroke-linejoin="round" />
        </svg>
      </button>
    </header>

    <aside id="sidebar" class="col-left">
      <div class="left-head row">
        <div style="font-weight:600">Sessions</div>
        <div class="spacer"></div>
        <button id="newSessionBtn" class="btn btnSq"><svg width="16px" height="16px" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg">
            <path d="M6 12H18M12 6V18" stroke="#ffffff" stroke-width="2" stroke-linecap="round"
              stroke-linejoin="round" />
          </svg></button>
      </div>
      <div id="sessions" class="sessions"></div>
      <div id="backdrop" class="backdrop"></div>
    </aside>

    <main class="col-main">

      <div id="chat" class="chat"></div>

      <div class="composer">
        <!-- NEW: attachments preview row -->
        <div id="attachPreview" class="row" style="align-items:center; flex-wrap:wrap;"></div>

        <!-- existing -->
        <textarea id="prompt" class="input" placeholder="Message... (Shift+Enter = newline)"></textarea>

        <!-- NEW: attach button and hidden input -->
        <button id="attachBtn" class="sendButton" title="Attach images" style="display:none;"><svg width="24px"
            height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M14.2639 15.9375L12.5958 14.2834C11.7909 13.4851 11.3884 13.086 10.9266 12.9401C10.5204 12.8118 10.0838 12.8165 9.68048 12.9536C9.22188 13.1095 8.82814 13.5172 8.04068 14.3326L4.04409 18.2801M14.2639 15.9375L14.6053 15.599C15.4112 14.7998 15.8141 14.4002 16.2765 14.2543C16.6831 14.126 17.12 14.1311 17.5236 14.2687C17.9824 14.4251 18.3761 14.8339 19.1634 15.6514L20 16.4934M14.2639 15.9375L18.275 19.9565M18.275 19.9565C17.9176 20 17.4543 20 16.8 20H7.2C6.07989 20 5.51984 20 5.09202 19.782C4.71569 19.5903 4.40973 19.2843 4.21799 18.908C4.12796 18.7313 4.07512 18.5321 4.04409 18.2801M18.275 19.9565C18.5293 19.9256 18.7301 19.8727 18.908 19.782C19.2843 19.5903 19.5903 19.2843 19.782 18.908C20 18.4802 20 17.9201 20 16.8V16.4934M4.04409 18.2801C4 17.9221 4 17.4575 4 16.8V7.2C4 6.0799 4 5.51984 4.21799 5.09202C4.40973 4.71569 4.71569 4.40973 5.09202 4.21799C5.51984 4 6.07989 4 7.2 4H16.8C17.9201 4 18.4802 4 18.908 4.21799C19.2843 4.40973 19.5903 4.71569 19.782 5.09202C20 5.51984 20 6.0799 20 7.2V16.4934M17 8.99989C17 10.1045 16.1046 10.9999 15 10.9999C13.8954 10.9999 13 10.1045 13 8.99989C13 7.89532 13.8954 6.99989 15 6.99989C16.1046 6.99989 17 7.89532 17 8.99989Z"
              stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
          </svg></button>
        <input id="fileInput" type="file" accept="image/*" multiple class="hide" />

        <button id="sendBtn" class="sendButton"><svg width="24px" height="24px" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg">
            <path
              d="M16.6582 9.28638C18.098 10.1862 18.8178 10.6361 19.0647 11.2122C19.2803 11.7152 19.2803 12.2847 19.0647 12.7878C18.8178 13.3638 18.098 13.8137 16.6582 14.7136L9.896 18.94C8.29805 19.9387 7.49907 20.4381 6.83973 20.385C6.26501 20.3388 5.73818 20.0469 5.3944 19.584C5 19.053 5 18.1108 5 16.2264V7.77357C5 5.88919 5 4.94701 5.3944 4.41598C5.73818 3.9531 6.26501 3.66111 6.83973 3.6149C7.49907 3.5619 8.29805 4.06126 9.896 5.05998L16.6582 9.28638Z"
              stroke="#ffffff" stroke-width="2" stroke-linejoin="round" />
          </svg></button>
      </div>
    </main>
  </div>

  <div class="overlaySys hide" id="systemEditorWrap">
    <div class="modal">
      <textarea id="systemMsg" class="sysinput"
        placeholder="(Optional) e.g. 'You are a concise assistant. Answer with short bullets.'"></textarea>

      <div class="row between" id="systemActions" style="margin-top:8px">
        <div class="row" style="gap:8px">
          <button id="sysLocBtn" class="btn btnSq" type="button" title="Include location"><svg width="24px"
              height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M10 8L14 12M14 8L10 12M19 10.2C19 14.1764 15.5 17.4 12 21C8.5 17.4 5 14.1764 5 10.2C5 6.22355 8.13401 3 12 3C15.866 3 19 6.22355 19 10.2Z"
                stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg></button>
          <button id="sysTimeBtn" class="btn btnSq" type="button" title="Include time"><svg width="24px" height="24px"
              viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M3 5.5L5 3.5M21 5.5L19 3.5M9 9.5L15 15.5M15 9.5L9 15.5M20 12.5C20 16.9183 16.4183 20.5 12 20.5C7.58172 20.5 4 16.9183 4 12.5C4 8.08172 7.58172 4.5 12 4.5C16.4183 4.5 20 8.08172 20 12.5Z"
                stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg></button>
          <button id="sysUaBtn" class="btn btnSq" type="button" title="Include browser info"><svg width="24px"
              height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M3 3L21 21M12 18H12.01M6 6V17.8C6 18.9201 6 19.4802 6.21799 19.908C6.40973 20.2843 6.71569 20.5903 7.09202 20.782C7.51984 21 8.0799 21 9.2 21H15C15.9319 21 16.3978 21 16.7654 20.8478C17.2554 20.6448 17.6448 20.2554 17.8478 19.7654C18 19.3978 18 18.9319 18 18M8.6499 3H14.8C15.9201 3 16.4802 3 16.908 3.21799C17.2843 3.40973 17.5903 3.71569 17.782 4.09202C18 4.51984 18 5.0799 18 6.2V12.3501"
                stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg></button>
        </div>
        <div class="row" style="gap:8px">
          <button id="sysGenBtn" class="btn" type="button"><svg width="24px" height="24px" viewBox="0 0 24 24"
              fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M5 16V20M6 4V8M7 18H3M8 6H4M13 4L14.7528 8.44437C14.9407 8.92083 15.0347 9.15906 15.1786 9.35994C15.3061 9.538 15.462 9.69391 15.6401 9.82143C15.8409 9.9653 16.0792 10.0593 16.5556 10.2472L21 12L16.5556 13.7528C16.0792 13.9407 15.8409 14.0347 15.6401 14.1786C15.462 14.3061 15.3061 14.462 15.1786 14.6401C15.0347 14.8409 14.9407 15.0792 14.7528 15.5556L13 20L11.2472 15.5556C11.0593 15.0792 10.9653 14.8409 10.8214 14.6401C10.6939 14.462 10.538 14.3061 10.3599 14.1786C10.1591 14.0347 9.92083 13.9407 9.44437 13.7528L5 12L9.44437 10.2472C9.92083 10.0593 10.1591 9.9653 10.3599 9.82143C10.538 9.69391 10.6939 9.538 10.8214 9.35994C10.9653 9.15906 11.0593 8.92083 11.2472 8.44437L13 4Z"
                stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg></button>
          <button id="sysSaveBtn" class="btn" type="button"><svg width="24px" height="24px" viewBox="0 0 24 24"
              fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M9 11.2222L10.8462 13L15 9M21 20L17.6757 18.3378C17.4237 18.2118 17.2977 18.1488 17.1656 18.1044C17.0484 18.065 16.9277 18.0365 16.8052 18.0193C16.6672 18 16.5263 18 16.2446 18H6.2C5.07989 18 4.51984 18 4.09202 17.782C3.71569 17.5903 3.40973 17.2843 3.21799 16.908C3 16.4802 3 15.9201 3 14.8V7.2C3 6.07989 3 5.51984 3.21799 5.09202C3.40973 4.71569 3.71569 4.40973 4.09202 4.21799C4.51984 4 5.0799 4 6.2 4H17.8C18.9201 4 19.4802 4 19.908 4.21799C20.2843 4.40973 20.5903 4.71569 20.782 5.09202C21 5.51984 21 6.0799 21 7.2V20Z"
                stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg></button>
        </div>
      </div>
    </div>
    <div id="systemToggleBtnInside" class="sysBackdrop"></div>

  </div>

  <!-- Settings Modal -->
  <div id="overlay" class="overlay">
    <div class="modal">
      <h3>Settings</h3>
      <div class="field">
        <label>Hub address (signaling server) <span class="muted">(identifier.publicKeyHex64)</span></label>
        <input id="hubInput" class="text" placeholder="e.g. hub.0123abcd…64hex" spellcheck="false" />
      </div>

      <div class="chiprow">
        <div class="chip"><b id="hubChipIcon"></b><b id="hubChip"></b></div>
        <div id="linkIcon" style="margin: auto 0px;"></div>
        <div class="chip"><b id="meChipIcon"></b><b id="meChip"></b></div>
      </div>

      <div class="row" style="gap:20px;flex-wrap:wrap;justify-content: flex-start;">
        <div class="field"><label>Temperature</label><input id="optTemperature" class="num" type="number" step="0.01"
            min="0" max="2" /></div>
        <div class="field"><label>Top-p</label><input id="optTopP" class="num" type="number" step="0.01" min="0"
            max="1" /></div>
        <div class="field"><label>Seed</label><input id="optSeed" class="num" type="number" step="1" /></div>
        <div class="field"><label>Context (num_ctx)</label><input id="optNumCtx" class="num" type="number" step="1"
            min="128" /></div>
        <div class="field">
          <label>Peers (subclients)</label>
          <input id="optPeers" class="num" type="number" step="1" min="1" max="12" />
        </div>

      </div>
      <div class="field">
        <div class="chkrow">
          <input id="optStream" type="checkbox" />
          <label for="optStream">Stream responses by default</label>
        </div>
        <div class="muted" style="margin-top:2px">Uncheck to request non-streaming results.</div>
      </div>
      <div class="row">
        <button id="resetKeyBtn" class="btn" style="border-color:#e84d4d;color:#e84d4d;background:#0a0a0a">Reset
          Key</button>
        <div class="spacer"></div>
        <button id="closeModal" class="btn" style="background:#0a0a0a;border-color:#2a2a2a">Close</button>
        <button id="saveSettings" class="btn">Save</button>
      </div>
      <div class="muted" style="font-size:12px;margin-top:6px">
        Resets your local NKN seed (32‑byte) and reconnects with a new keypair.
      </div>
    </div>
    <div class="backdropModal" id="backdropModal"></div>
  </div>

  <!-- Copy-to-clipboard helper for code blocks -->
  <script>
    (() => {
      const style = document.createElement('style');
      style.textContent = `
    pre { position: relative; }
    .code-copy-btn {
      position: absolute; top: 8px; right: 8px;
      background: rgba(255,255,255,.06);
      border: 1px solid #2a2a2a;
      color: #eaeaea;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
    }
    .code-copy-btn:active { transform: translateY(1px); }
    .code-copy-btn.ok {
      border-color: #4caf50;
      color: #b2fab4;
    }
  `;
      document.head.appendChild(style);

      const hasSelection = () => {
        const sel = window.getSelection && window.getSelection();
        return sel && String(sel).length > 0;
      };
      const flash = (btn, msg = 'Copied!') => {
        const orig = btn.textContent;
        btn.textContent = msg;
        btn.classList.add('ok');
        setTimeout(() => {
          btn.textContent = orig;
          btn.classList.remove('ok');
        }, 1200);
      };
      const fallbackCopy = (text, btn) => {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.top = '-1000px';
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        try { flash(btn, document.execCommand('copy') ? 'Copied!' : 'Failed'); }
        catch { flash(btn, 'Failed'); }
        finally { document.body.removeChild(ta); }
      };
      const doCopy = (codeEl, btn) => {
        const text = codeEl.textContent || '';
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(
            () => flash(btn, 'Copied!'),
            () => fallbackCopy(text, btn)
          );
        } else fallbackCopy(text, btn);
      };
      const attachButton = (codeEl) => {
        if (!codeEl || codeEl.dataset.copyAttached === '1') return;
        const pre = codeEl.closest('pre'); if (!pre) return;
        if (pre.querySelector('.code-copy-btn')) { codeEl.dataset.copyAttached = '1'; return; }
        const btn = document.createElement('button');
        btn.type = 'button'; btn.className = 'code-copy-btn'; btn.textContent = 'Copy';
        pre.appendChild(btn);
        btn.addEventListener('click', (e) => { e.stopPropagation(); doCopy(codeEl, btn); });
        pre.addEventListener('click', () => { if (!hasSelection()) doCopy(codeEl, btn); });
        codeEl.dataset.copyAttached = '1';
      };
      const scan = (root = document) => { root.querySelectorAll('pre > code').forEach(attachButton); };
      const mo = new MutationObserver((muts) => {
        for (const m of muts) m.addedNodes && m.addedNodes.forEach((n) => {
          if (n.nodeType !== 1) return;
          if (n.matches && n.matches('pre > code')) attachButton(n); else scan(n);
        });
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', () => scan()); else scan();
    })();
  </script>


  <script>
    (() => {
      // ---- Singleton guard (unique key for your app) --------------------------
      const SINGLETON_KEY = '__NKN_CHAT_APP__';
      if (window[SINGLETON_KEY]?.alive) {
        // Already initialized — ignore duplicate loads cleanly.
        if (window._PKT?.DEBUG?.ON) console.warn('[app] duplicate script load ignored');
        return;
      }
      // mark the singleton as alive early to prevent re-entry
      window[SINGLETON_KEY] = { alive: true, booted: false, api: null };
      // -------------------------------------------------------------------------
      // ===== DEBUG / Packet instrumentation (drop-in) ============================
      const LS_KEY = 'DEBUG_PKT';
      const INIT_DEBUG = (localStorage.getItem(LS_KEY) ?? '0') !== '0'; // default OFF; use window.togglePkt(true) to enable


      const DEBUG = {
        ON: INIT_DEBUG,           // toggle with window.togglePkt(true|false)
        LOG_CONTENT: false,       // if true, dump payloads (truncated)
        MAX_DUMP: 512,            // max chars to dump
        WARN_FRAME_LIMIT: 64 * 1024, // warn when a single JSON frame exceeds this many bytes
        LOG_STREAM_EVERY_N: 1,    // set to 5 to log every 5th llm.chunk
      };
      const STATS = {
        sends: 0, recvs: 0, sendBytes: 0, recvBytes: 0, maxSend: 0, maxRecv: 0
      };

      function shortAddr(s) {
        s = String(s || '');
        return s.length > 18 ? (s.slice(0, 7) + '…' + s.slice(-6)) : (s || '—');
      }
      function humanBytes(n) {
        if (!Number.isFinite(n)) return String(n);
        const u = ['B', 'KB', 'MB', 'GB']; let i = 0; while (n >= 1024 && i < u.length - 1) { n /= 1024; i++; }
        return `${n.toFixed(n < 10 && i ? 2 : 0)} ${u[i]}`;
      }
      function byteLenOfString(s) { return new Blob([String(s || '')]).size; }
      function byteLenOfJSON(o) { try { return byteLenOfString(JSON.stringify(o)); } catch { return 0; } }
      function approxB64ToBinLen(b64) {
        const len = (b64 || '').length;
        const pad = (b64.endsWith('==') ? 2 : (b64.endsWith('=') ? 1 : 0));
        return Math.max(0, Math.floor(len * 3 / 4) - pad);
      }
      function sampleStr(s, n = DEBUG.MAX_DUMP) {
        s = String(s || '');
        if (s.length <= n) return s;
        const half = Math.floor(n / 2);
        return s.slice(0, half) + ' … ' + s.slice(-half);
      }
      function nowIso() { return new Date().toISOString(); }

      function logSendPacket(addr, obj, sendOpts, extra = {}) {
        if (!DEBUG.ON) return;
        const json = JSON.stringify(obj);
        const jsonBytes = byteLenOfString(json);
        STATS.sends++; STATS.sendBytes += jsonBytes; STATS.maxSend = Math.max(STATS.maxSend, jsonBytes);
        const tag = obj.event || obj.api || '—';
        console.groupCollapsed(
          `%c[SEND] %c${tag} %c→ ${shortAddr(addr)} %c${humanBytes(jsonBytes)}`,
          'color:#888', 'color:#0af', 'color:#888', 'color:#0a0'
        );
        console.log({ when: nowIso(), bytes: jsonBytes, addr, sendOpts, ...extra });
        if (obj.event === 'blob.part') {
          const b64 = obj.data || '';
          const approxRaw = approxB64ToBinLen(b64);
          console.log('blob.part meta', {
            id: obj.id, seq: obj.seq, b64Len: b64.length,
            approxRaw, jsonBytes
          });
          if (jsonBytes > DEBUG.WARN_FRAME_LIMIT) {
            console.warn('⚠️ JSON frame above WARN_FRAME_LIMIT', jsonBytes);
          }
          if (DEBUG.LOG_CONTENT) console.log('b64 sample', sampleStr(b64));
        } else {
          if (DEBUG.LOG_CONTENT) console.log('payload', obj);
        }
        console.groupEnd();
      }

      function logRecvPacket(src, raw, body) {
        if (!DEBUG.ON) return;
        const ev = body?.event || '—';

        // Gate verbose logs during streaming: log every Nth llm.chunk only
        if (ev === 'llm.chunk') {
          const seq = Number(body?.seq || 0);
          const N = Math.max(1, Number(DEBUG.LOG_STREAM_EVERY_N) || 1); // set N=5 to sample every 5th
          if (seq % N !== 0) return;
        }

        let bytes = 0;
        try {
          if (typeof raw === 'string') bytes = byteLenOfString(raw);
          else if (raw instanceof Uint8Array) bytes = raw.byteLength;
          else if (raw && typeof raw === 'object' && typeof raw.payload === 'string') bytes = byteLenOfString(raw.payload);
          else if (raw && raw.data && typeof raw.data === 'string') bytes = byteLenOfString(raw.data);
        } catch { }

        STATS.recvs++; STATS.recvBytes += bytes; STATS.maxRecv = Math.max(STATS.maxRecv, bytes);
        console.groupCollapsed(
          `%c[RECV] %c${ev} %c← ${shortAddr(src || '')} %c${humanBytes(bytes)}`,
          'color:#888', 'color:#0af', 'color:#888', 'color:#0a0'
        );
        const id = body?.id; const kind = body?.api || body?.kind;
        console.log({ when: nowIso(), bytes, id, kind, from: src });
        if (DEBUG.LOG_CONTENT) console.log('body', body);
        console.groupEnd();
      }


      function warnIfLargeFrame(obj, where = '') {
        const bytes = byteLenOfJSON(obj);
        if (bytes > DEBUG.WARN_FRAME_LIMIT) {
          console.warn(`⚠️ Large frame (${humanBytes(bytes)}) at ${where}`, (obj?.event || obj?.api || ''));
        }
      }

      // expose for quick toggling / stats in console
      window._PKT = { DEBUG, STATS, helpers: { humanBytes, byteLenOfJSON, approxB64ToBinLen } };
      window.togglePkt = (on) => { DEBUG.ON = !!on; localStorage.setItem(LS_KEY, DEBUG.ON ? '1' : '0'); console.log('[debug-pkt]', DEBUG.ON ? 'ON' : 'OFF'); };
      window.dumpPktStats = function () {
        console.table({
          sends: STATS.sends, recvs: STATS.recvs,
          sendBytes: STATS.sendBytes, recvBytes: STATS.recvBytes,
          maxSend: STATS.maxSend, maxRecv: STATS.maxRecv
        });
      };

      // also surface warnings for suppressed unhandled rejections while debugging
      const origUH = window.onunhandledrejection;
      window.addEventListener('unhandledrejection', (e) => {
        if (DEBUG.ON) console.warn('[PromiseRejection suppressed]', e?.reason?.message || e?.reason || e);
        if (origUH) try { origUH.call(window, e); } catch { }
      }, { capture: true });

      // ─────────── Utils & storage
      const $ = s => document.querySelector(s);
      const el = id => document.getElementById(id);
      const short = s => s ? (s.slice(0, 7) + '…' + s.slice(-6)) : '—';
      const isNknAddr = s => /^[A-Za-z0-9_-]+\.[0-9a-f]{64}$/.test((s || '').trim());
      const debounce = (fn, ms = 300) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };

      // Markdown + code highlighting setup (safer: no raw HTML, safe links)
      marked.setOptions({ gfm: true, breaks: true, headerIds: false, mangle: false });
      marked.use({
        // drop any raw HTML tokens entirely
        renderer: {
          html() { return ''; },
          link(href, title, text) {
            // allow only http(s) and mailto; everything else becomes a harmless "#"
            const safe = /^(https?:|mailto:)/i.test(href || '') ? href : '#';
            const esc = (s = '') => String(s).replace(/"/g, '&quot;');
            const t = title ? ` title="${esc(title)}"` : '';
            return `<a href="${esc(safe)}"${t} rel="nofollow noopener noreferrer" target="_blank">${text}</a>`;
          }
        }
      });
      function mdToHtml(s) { try { return marked.parse(String(s || '')); } catch { return String(s || ''); } }

      function highlightIn(node) { try { node.querySelectorAll('pre code').forEach(block => { try { hljs.highlightElement(block); } catch { } }); } catch { } }

      const STORAGE = {
        SESS: 'CLIENT_SESSIONS_V2',
        SETTINGS: 'CLIENT_SETTINGS_V2',
        SEED: 'CLIENT_SEED_HEX_V2',
        HUB: 'CLIENT_HUB_ADDR_V2',
        LEGACY_SEED: 'PEERBALLS_SEED_HEX',
        LEGACY_HUB: 'PEERBALLS_HUB_ADDR',
        LAST_MODEL: 'CLIENT_LAST_SELECTED_MODEL_V2',
        MODELINFO: 'CLIENT_MODEL_INFO_CACHE_V1'      // ← NEW
      };


      function loadJSON(key, fallback) {
        try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); } catch { return fallback; }
      }
      function saveJSON(key, val) { localStorage.setItem(key, JSON.stringify(val)); }

      // ── Model info cache (caps etc.) ──────────────────────────────────────────
      const MODEL_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days
      const MODEL_CACHE_MAX = 50;

      let modelInfoCache = loadJSON(STORAGE.MODELINFO, {}); // { [model]: { ...info, _cachedAt } }

      function cacheSetModelInfo(model, info) {
        if (!model || !info) return;
        // keep it lean: store only what we render / use
        const slim = {
          name: info.name || model,
          format: info.format || null,
          parameter_size: info.parameter_size || null,
          quantization: info.quantization || null,
          num_ctx: info.num_ctx || null,
          capabilities: Array.isArray(info.capabilities) ? info.capabilities.map(String) : [],
          modified_at: info.modified_at || null,
          _cachedAt: Date.now()
        };
        modelInfoCache[model] = slim;

        // LRU-ish cap
        const keys = Object.keys(modelInfoCache);
        if (keys.length > MODEL_CACHE_MAX) {
          keys
            .map(k => [k, modelInfoCache[k]?._cachedAt || 0])
            .sort((a, b) => a[1] - b[1])
            .slice(0, keys.length - MODEL_CACHE_MAX)
            .forEach(([k]) => delete modelInfoCache[k]);
        }
        saveJSON(STORAGE.MODELINFO, modelInfoCache);
      }

      function cacheGetModelInfo(model) {
        const rec = modelInfoCache && modelInfoCache[model];
        if (!rec) return null;
        if ((Date.now() - (rec._cachedAt || 0)) > MODEL_CACHE_TTL_MS) {
          delete modelInfoCache[model];
          saveJSON(STORAGE.MODELINFO, modelInfoCache);
          return null;
        }
        return rec;
      }

      function tryRenderModelInfoFromCache(model) {
        const row = el('modelCaps'); if (row) { row.style.display = 'flex'; }
        const info = cacheGetModelInfo(model);
        if (!info) return false;
        renderModelInfo(info);
        const hasVision = Array.isArray(info.capabilities) && info.capabilities.some(c => String(c).toLowerCase() === 'vision');
        toggleImageAttach(!!hasVision);
        return true;
      }


      const toHex = buf => Array.from(buf).map(b => b.toString(16).padStart(2, '0')).join('');
      function getOrCreateSeed() {
        let hex = localStorage.getItem(STORAGE.SEED) || localStorage.getItem(STORAGE.LEGACY_SEED);
        if (/^[0-9a-f]{64}$/.test(hex || '')) return hex;
        const r = new Uint8Array(32); crypto.getRandomValues(r); hex = toHex(r);
        localStorage.setItem(STORAGE.SEED, hex); return hex;
      }

      // Settings
      const settings = (() => {
        const defaultHub = localStorage.getItem(STORAGE.HUB) || localStorage.getItem(STORAGE.LEGACY_HUB) || '';
        return loadJSON(STORAGE.SETTINGS, {
          hub: defaultHub,
          temperature: 0.2,
          top_p: 0.9,
          seed: 0,
          num_ctx: 4096,
          stream: true,
          peers: 4,           // ← NEW: target subclients
        });
      })();
      // --- URL param → hub (supports ?hub=… or #hub=… and aliases) ---
      function getUrlHubParam() {
        const tryRead = (sp) => sp.get('hub') || sp.get('nkn') || sp.get('signaling') || sp.get('signal');
        let v = '';
        try { v = tryRead(new URLSearchParams(location.search)) || ''; } catch { }
        if (!v && location.hash && location.hash.includes('=')) {
          try { v = tryRead(new URLSearchParams(location.hash.slice(1))) || ''; } catch { }
        }
        return (v || '').trim();
      }
      function applyHubFromUrl() {
        const h = getUrlHubParam();
        if (h && isNknAddr(h)) {
          settings.hub = h;
          saveJSON(STORAGE.SETTINGS, settings);
          localStorage.setItem(STORAGE.HUB, h);
          try {
            const url = new URL(location.href);
            ['hub', 'nkn', 'signaling', 'signal'].forEach(k => url.searchParams.delete(k));
            history.replaceState(null, '', url.toString());
          } catch { }
        }
      }

      function updateSettingsUI() {
        el('hubInput').value = settings.hub || '';
        el('optTemperature').value = settings.temperature;
        el('optTopP').value = settings.top_p;
        el('optSeed').value = settings.seed;
        el('optNumCtx').value = settings.num_ctx;
        el('optStream').checked = !!settings.stream;
        const p = Number(settings.peers || 6);
        const peersBox = el('optPeers'); if (peersBox) peersBox.value = Math.max(1, Math.min(12, p));
      }

      function saveSettingsFromUI() {
        const prevHub = settings.hub;
        const prevPeers = Number(settings.peers || 4);

        const hub = el('hubInput').value.trim();
        if (!isNknAddr(hub)) { alert('Invalid hub address'); return false; }

        settings.hub = hub;
        settings.temperature = parseFloat(el('optTemperature').value || '0') || 0;
        settings.top_p = parseFloat(el('optTopP').value || '1') || 1;
        settings.seed = parseInt(el('optSeed').value || '0', 10) || 0;
        settings.num_ctx = parseInt(el('optNumCtx').value || '4096', 10) || 4096;
        settings.stream = !!el('optStream').checked;

        const peersBox = el('optPeers');
        const newPeers = Math.max(1, Math.min(12, parseInt(peersBox?.value || '4', 10) || 4));
        settings.peers = newPeers;

        saveJSON(STORAGE.SETTINGS, settings);
        localStorage.setItem(STORAGE.HUB, settings.hub);

        // If hub or peer target changed, reconnect to apply
        if (prevHub !== settings.hub || prevPeers !== newPeers) {
          try { client && client.close && client.close(); } catch { }
          client = null;
          isConnected = false;
          connectNKN();
          return false;
        }

        const s = getSession(); if (s) sendSessionOpen(s, /*seed*/false);
        return true;
      }

      // Sessions
      let sessions = loadJSON(STORAGE.SESS, []);

      // ── MIGRATION: normalize any message roles that were accidentally set to the model name.
      (function migrateSessionRoles() {
        let dirty = false;
        for (const s of (sessions || [])) {
          for (const m of (s?.messages || [])) {
            // Keep a copy of the old value if it wasn't one of the canonical roles
            if (m && typeof m.role === 'string' &&
              m.role !== 'user' && m.role !== 'assistant' && m.role !== 'system') {
              // Preserve who answered (for display/debug) without breaking role semantics
              if (!m.agent) m.agent = m.role; // e.g., "gemma3:4b"
              m.role = 'assistant';
              dirty = true;
            }
          }
        }
        if (dirty) saveJSON(STORAGE.SESS, sessions);
      })();

      let activeSessionId = (sessions[0]?.id) || null;

      // ── Blob upload (chunked) ─────────────────────────────────────────────
      const PACK_INLINE_MAX = 120 * 1024;
      // Keep each websocket frame <= ~64 KiB including JSON + base64 overhead to avoid WS closes.
      const BLOB_CHUNK_SIZE = 32 * 1024;   // 32 KiB raw → ~43.7 KiB base64
      let BLOB_WINDOW = 1;                  // keep concurrency low; we'll cap it to at most 2

      // NEW: how long we wait before re-nudging the hub if no accept/acks
      const UPLOAD_ACCEPT_TIMEOUT_MS = 2000;

      const uploads = new Map(); // blobId -> { file, name, mime, size, total, chunkSize, nextSeq, inflight:Set, acked:Set, done, readyRef, sha256?, startedAt }

      let pendingBlobRefs = [];  // refs ready to use in next message (e.g. ['blob:...'])

      function abToBase64(buf) {
        let binary = '';
        const bytes = new Uint8Array(buf);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
      }

      const getSavedModel = () => localStorage.getItem(STORAGE.LAST_MODEL) || (sessions[0]?.model || '');
      const setSavedModel = (m) => { if (m) localStorage.setItem(STORAGE.LAST_MODEL, m); };

      function getCurrentModel() {
        const s = getSession();
        const candidate =
          (s && s.model) ||
          (el('modelSelect') && el('modelSelect').value) ||
          getSavedModel() ||
          '';
        return isValidModelName(candidate) ? candidate : '';
      }
      function looksLikeModels(x) {
        const d = x?.data ?? x;
        return Array.isArray(d) ||
          Array.isArray(d?.models) ||
          Array.isArray(d?.data?.models) ||
          Array.isArray(d?.list) ||           // some hubs use {list:[...]}
          Array.isArray(d?.data?.list);
      }

      function newBlobId() { return 'b' + Date.now().toString(36) + Math.random().toString(16).slice(2, 10); }

      // ── Stage locally; no network yet
      async function stageBlob(file) {
        const fp = [file.name || '', file.size || 0, file.lastModified || 0].join(':');

        for (const [id, up] of uploads.entries()) {
          if (up.fp === fp && !up.done) return id;
        }

        const id = newBlobId();
        const size = file.size;
        const name = file.name || 'file';
        const mime = file.type || 'application/octet-stream';
        const chunkSize = BLOB_CHUNK_SIZE;
        const total = Math.ceil(size / chunkSize);

        const up = {
          file, name, mime, size, total, chunkSize,
          nextSeq: 0,
          inflight: new Set(),
          acked: new Set(),
          done: false,
          readyRef: null,
          startedAt: 0,
          rtts: [],
          fp,
          acceptWatch: null,
          retryTicker: null,
          partRetryMs: 0,  // computed from RTTs
          // staged pipeline
          staged: true,
          uploading: false,
          readyPromise: null,
          _resolveReady: null,
          _rejectReady: null,

          // no-ack fallback + finish nudging
          noAckMode: false,
          noAckTimer: null,
          windowNoAck: 2,      // small throttle when no ACKs flow
          doneSent: false,
          doneTicker: null,
        };

        up.readyPromise = new Promise((resolve, reject) => {
          up._resolveReady = resolve;
          up._rejectReady = reject;
        });

        uploads.set(id, up);
        return id;
      }

      function beginUpload(id) {
        const up = uploads.get(id);
        if (!up || up.done || up.uploading) return;

        up.uploading = true;
        up.startedAt = Date.now();
        up.nextSeq = 0;
        up.inflight.clear();
        up.acked.clear();
        up.noAckMode = false;
        clearTimeout(up.noAckTimer);
        clearTimeout(up.acceptWatch);
        if (up.doneTicker) { clearInterval(up.doneTicker); up.doneTicker = null; }
        up.doneSent = false;

        console.groupCollapsed('%c[BLOB.INIT]', 'color:#0af',
          { id, name: up.name, size: up.size, chunkSize: up.chunkSize, totalChunks: up.total });
        console.log(up);
        console.groupEnd();

        trySend(HUB_ADDR, {
          event: 'blob.init',
          id,
          name: up.name,
          mime: up.mime,
          size: up.size,
          chunkSize: up.chunkSize,
          total: up.total,
          sha256: up.sha256
        });

        up.noAckTimer = setTimeout(() => {
          if (!up.done && up.uploading) {
            up.noAckMode = true;
            console.warn('[BLOB.NO-ACK MODE]', { id, window: up.windowNoAck });
            pumpBlob(id);
          }
        }, 1200);

        const armWatchdog = () => {
          clearTimeout(up.acceptWatch);
          up.acceptWatch = setTimeout(() => {
            console.warn('[BLOB.ACCEPT-WATCHDOG]', { id });
            trySend(HUB_ADDR, {
              event: 'blob.init',
              id,
              name: up.name,
              mime: up.mime,
              size: up.size,
              chunkSize: up.chunkSize,
              total: up.total
            });
            pumpBlob(id);
            armWatchdog();
          }, UPLOAD_ACCEPT_TIMEOUT_MS);
        };
        armWatchdog();

        setTimeout(() => pumpBlob(id), 0);
        startBlobRetryWatch(id);
      }

      async function sendBlobPartBySeq(id, seq) {
        const up = uploads.get(id); if (!up || up.done || !up.uploading) return;
        const start = seq * up.chunkSize;
        const end = Math.min(up.size, start + up.chunkSize);
        const blob = up.file.slice(start, end);
        const buf = await blob.arrayBuffer();
        const b64 = abToBase64(buf);

        up['t' + seq] = Date.now();
        // we don't re-add to inflight (it’s already there); just resend
        const wire = { event: 'blob.part', id, seq, data: b64 };
        const sendOpts = { noReply: true, msgHoldingSeconds: 600, responseTimeout: 15000 };
        if (window._PKT?.DEBUG?.ON) logSendPacket(HUB_ADDR, wire, sendOpts, { flow: 'blob.retx', seq });
        try { await client.send(HUB_ADDR, JSON.stringify(wire), sendOpts); } catch { }
      }

      function startBlobRetryWatch(id) {
        const up = uploads.get(id); if (!up) return;
        if (up.retryTicker) { clearInterval(up.retryTicker); up.retryTicker = null; }


        up.retryTicker = setInterval(() => {
          if (!up.uploading || up.done) return;

          // dynamic resend threshold: ~3x smoothed RTT (bounds: 1500..10000ms)
          const avg = up.rtts.length ? (up.rtts.reduce((a, b) => a + b, 0) / up.rtts.length) : 800;
          const threshold = up.partRetryMs = Math.max(1500, Math.min(10000, avg * 3));

          const now = Date.now();
          for (const seq of Array.from(up.inflight)) {
            const t0 = up['t' + seq] || 0;
            if (!t0 || (now - t0) > threshold) {
              // stale → retransmit part
              sendBlobPartBySeq(id, seq);
            }
          }

          // If we have sent all parts and the pipe looks empty, keep nudging 'done'
          if (up.nextSeq >= up.total && up.inflight.size === 0 && !up.done) {
            console.info('[BLOB.DONE → announce]', { id });
            trySend(HUB_ADDR, { event: 'blob.done', id });
            if (!up.doneTicker) {
              up.doneTicker = setInterval(() => {
                if (!up.done) trySend(HUB_ADDR, { event: 'blob.done', id });
              }, 1500);
            }
          }
        }, 800);
      }

      async function pumpBlob(id) {
        const up = uploads.get(id);
        if (!up || up.done || !client || !isConnected || !up.uploading) return;

        while (up.inflight.size < (up.window || BLOB_WINDOW) && up.nextSeq < up.total) {
          const seq = up.nextSeq++;
          const start = seq * up.chunkSize;
          const end = Math.min(up.size, start + up.chunkSize);
          const blob = up.file.slice(start, end);
          const buf = await blob.arrayBuffer();
          const b64 = abToBase64(buf);

          up.inflight.add(seq);
          up['t' + seq] = Date.now();

          // Build the wire object & log sizes BEFORE sending
          const wire = { event: 'blob.part', id, seq, data: b64 };
          const sendOpts = { noReply: true, msgHoldingSeconds: 600, responseTimeout: 15000 };
          logSendPacket(HUB_ADDR, wire, sendOpts, {
            flow: 'blob.upload',
            seq,
            total: up.total,
            window: (up.window || BLOB_WINDOW)
          });

          // Fine‑grained warning if frame looks large
          const jbytes = (window._PKT && _PKT.helpers) ? _PKT.helpers.byteLenOfJSON(wire) : JSON.stringify(wire).length;
          if (jbytes > (window._PKT?.DEBUG?.WARN_FRAME_LIMIT ?? 65536)) {
            console.warn('⚠️ blob.part JSON frame close to/over limit', { id, seq, jbytes });
          }

          try {
            await client.send(HUB_ADDR, JSON.stringify(wire), sendOpts);
          } catch (e) {
            up.inflight.delete(seq);
            up.nextSeq = Math.min(up.nextSeq, seq);
            console.error('[BLOB.SEND-ERROR]', { id, seq, message: e?.message || String(e) });
            setTimeout(() => pumpBlob(id), 250);
            return;
          }
        }

        if (up.nextSeq >= up.total && up.inflight.size === 0 && !up.done) {
          console.info('[BLOB.DONE? → announce]', { id });
          trySend(HUB_ADDR, { event: 'blob.done', id });
        }
      }


      function newId(prefix = 'id') { return prefix + '-' + Math.random().toString(16).slice(2) + Date.now().toString(36); }
      function createSessionForModel(model) {
        if (!modelsLoaded || !isValidModelName(model)) {
          console.warn('[session] blocked: model list not ready or invalid model:', model);
          try { alert('Models are not ready yet. Please wait for the list to load.'); } catch { }
          return;
        }
        const id = newId('sess');
        const s = { id, title: model, model, system: '', createdAt: Date.now(), messages: [] };
        sessions.unshift(s);
        activeSessionId = id;
        saveJSON(STORAGE.SESS, sessions);
        setSavedModel(model);

        renderSessions();
        renderSystemEditor();
        renderChat();
        sendSessionOpen(s, /*seed*/true);

        // prime the UI + cache
        updateModelInfo(model);
      }

      function getSession(id = activeSessionId) { return sessions.find(x => x.id === id) || null; }
      function setActiveSession(id) {
        activeSessionId = id;
        const s = getSession();
        if (s && s.model) {
          setSavedModel(s.model);
          const sel = el('modelSelect');
          if (sel && Array.from(sel.options).some(o => o.value === s.model)) sel.value = s.model;

          // NEW: update caps row when switching sessions (no server hit if cached)
          if (!tryRenderModelInfoFromCache(s.model)) {
            // Only fetch if not cached (avoids repeated round-trips when hopping sessions)
            fetchModelInfo(s.model, (res) => {
              if (!res?.ok) return;
              const data = (res.body && (res.body.data || res.body)) || {};
              console.log(data)
              const info = normalizeModelShow(s.model, data);
              console.log(info)
              renderModelInfo(info);
              const hasVision = Array.isArray(info.capabilities) && info.capabilities.some(c => String(c).toLowerCase() === 'vision');
              toggleImageAttach(!!hasVision);
              cacheSetModelInfo(s.model, info);
            });
          }
        }
        renderSessions(); renderSystemEditor(); renderChat();
        if (s) sendSessionOpen(s, /*seed*/true);
      }
      function appendMessage(sessId, role, content) {
        const s = getSession(sessId); if (!s) return;
        s.messages.push({ role, content, ts: Date.now() });

        // soft cap: keep most recent ~400 messages per session
        const MAX_LOCAL_MSGS = 400;
        if (s.messages.length > MAX_LOCAL_MSGS) {
          s.messages.splice(0, s.messages.length - MAX_LOCAL_MSGS);
        }
        saveJSON(STORAGE.SESS, sessions);
      }

      function updateLastAssistantContent(sessId, content) {
        const s = getSession(sessId); if (!s) return;
        for (let i = s.messages.length - 1; i >= 0; i--) {
          if (s.messages[i].role === 'assistant') { s.messages[i].content = content; break; }
        }
        saveJSON(STORAGE.SESS, sessions);
      }
      function deleteSession(id) {
        const idx = sessions.findIndex(x => x.id === id);
        if (idx === -1) return;
        const sid = sessions[idx].id;
        sendSessionReset(sid);
        sessions.splice(idx, 1);
        saveJSON(STORAGE.SESS, sessions);
        if (activeSessionId === id) activeSessionId = sessions[0]?.id || null;
        if (sessions[0]?.model) setSavedModel(sessions[0].model);
        renderSessions(); renderSystemEditor(); renderChat();
        if (activeSessionId) { const s = getSession(); if (s) sendSessionOpen(s, /*seed*/true); }
      }

      function renderSessions() {
        const box = el('sessions'); box.innerHTML = '';
        sessions.forEach(s => {
          const div = document.createElement('div'); div.className = 'session' + (s.id === activeSessionId ? ' active' : '');
          div.onclick = () => setActiveSession(s.id);
          div.innerHTML = `
        <div class="title">${s.title || s.model || 'Session'}</div>
        <small>${s.model || ''} • ${new Date(s.createdAt).toLocaleString()}</small>
        <button class="del" title="Delete session" aria-label="Delete"><svg width="16px" height="16px" viewBox="0 0 24 24" style="transform:rotate(45deg);" fill="none"
            xmlns="http://www.w3.org/2000/svg">
            <path d="M6 12H18M12 6V18" stroke="#ffffff" stroke-width="2" stroke-linecap="round"
              stroke-linejoin="round" />
          </svg></button>
      `;
          const del = div.querySelector('.del');
          del.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('Delete this session?')) deleteSession(s.id);
          });
          box.appendChild(div);
        });
      }

      // Markdown renderer for message body
      function messageHtml(role, content) { return mdToHtml(content || ''); }

      function renderSystemEditor() {
        const s = getSession();
        const ta = el('systemMsg');
        if (!s) {
          ta.value = '';
          ta.placeholder = '(Select or create a session to set a system prompt)';
          ta.disabled = true;
          return;
        }
        ta.disabled = false;
        ta.value = s.system || '';
        ta.placeholder = "(Optional) e.g. 'You are a concise assistant. Answer with short bullets.'";

        // keep metadata block in sync with toggles when opening the editor
        applySystemMeta(false);
        updateSysMetaButtons();
      }


      // ── Sticky autoscroll manager ───────────────────────────────────────────────
      const StickyScroll = (() => {
        const BOTTOM_STICK_THRESHOLD = 80; // px user must be within to count as "at bottom"

        let chatEl = null;
        let btn = null;
        let isSticky = true;       // "stick to bottom" only while generating
        let isGenerating = false;

        const arrowSvg = `
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none"
         xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M12 5v12m0 0l-5-5m5 5l5-5" stroke="#ffffff"
            stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;

        function distToBottom() {
          if (!chatEl) return 0;
          return Math.max(0, chatEl.scrollHeight - (chatEl.scrollTop + chatEl.clientHeight));
        }
        function atBottom() { return distToBottom() <= BOTTOM_STICK_THRESHOLD; }

        function scrollToBottom(smooth = true) {
          if (!chatEl) return;
          const top = chatEl.scrollHeight;
          chatEl.scrollTo({ top, behavior: smooth ? 'smooth' : 'auto' });
        }

        function setBtnVisible(show) {
          if (!btn) return;
          btn.style.display = show ? 'flex' : 'none';
        }

        function updateBtn() {
          // show only when: generating, not sticky, and there’s content below
          setBtnVisible(isGenerating && !isSticky && distToBottom() > BOTTOM_STICK_THRESHOLD);
        }

        function onScroll() {
          if (!chatEl) return;

          // Only manage stickiness during generation
          if (!isGenerating) { updateBtn(); return; }

          if (atBottom()) {
            // user intentionally scrolled to bottom → re-stick
            if (!isSticky) { isSticky = true; updateBtn(); }
          } else {
            // user pulled away while generating → unstick and show caret
            if (isSticky) { isSticky = false; updateBtn(); }
          }
        }

        function onContentAppended() {
          if (!chatEl) return;
          if (isGenerating && isSticky) {
            // keep pace with the stream with an immediate jump (no jitter)
            chatEl.scrollTop = chatEl.scrollHeight;
          } else {
            updateBtn();
          }
        }

        function setGenerating(flag) {
          isGenerating = !!flag;
          // (re-)compute stickiness at the moment generation starts
          if (isGenerating) {
            isSticky = atBottom(); // only stick if user is already near bottom
          }
          updateBtn();
        }

        function init(elChat) {
          if (!elChat || chatEl) return;
          chatEl = elChat;

          // floating button lives in the same positioned container as chat
          btn = document.createElement('button');
          btn.id = 'scrollToBottomBtn';
          btn.className = 'btn btnSq';
          btn.type = 'button';
          btn.title = 'Jump to latest';
          btn.innerHTML = arrowSvg;
          (chatEl.parentElement || document.body).appendChild(btn);

          btn.addEventListener('click', () => { isSticky = true; scrollToBottom(true); updateBtn(); });
          chatEl.addEventListener('scroll', onScroll, { passive: true });

          // initial state
          isSticky = true; isGenerating = false; updateBtn();
        }

        // expose a tiny API
        return { init, setGenerating, onContentAppended, scrollToBottom };
      })();


      function renderChat() {
        const s = getSession();
        const box = el('chat');
        if (!box) return;

        // one-time setup for sticky autoscroll manager
        if (!window.__stickyReady) {
          StickyScroll.init(box);
          window.__stickyReady = true;
        }

        // clear and (re)render
        box.innerHTML = '';

        if (!s) {
          box.innerHTML = `<div class="muted" style="text-align:center;margin-top:30px">
      Choose a model above to create a session.
    </div>`;
          StickyScroll.onContentAppended();
          return;
        }

        // identify the most recent assistant message (the one being streamed)
        let lastAssistantIdx = -1;
        for (let i = s.messages.length - 1; i >= 0; i--) {
          if (s.messages[i].role === 'assistant') { lastAssistantIdx = i; break; }
        }

        // live stream id & stats (set by setStopMode/onInbound handlers)
        const liveStreamId = currentStreamId || pendingStreamId || null;
        const liveStats = liveStreamId ? statsByStream.get(liveStreamId) : null;
        const liveTps = (liveStats && Number.isFinite(liveStats.tps) && liveStats.tps > 0) ? liveStats.tps : null;

        // render efficiently via a fragment to minimize layout thrash
        const frag = document.createDocumentFragment();

        s.messages.forEach((m, idx) => {
          const w = document.createElement('div');
          w.className = 'msg ' + (m.role === 'user' ? 'user' : 'assistant');

          const contentHtml = messageHtml(m.role, m.content);
          const whoLabel = (m.role === 'user') ? 'user' : (m.agent || s.model || 'assistant');

          let imagesHtml = '';
          if (Array.isArray(m.images) && m.images.length) {
            imagesHtml = `<div class="row" style="margin-top:6px;flex-wrap:wrap;gap:6px;">${m.images.map(src => `<img src="${src}" alt="" style="width:140px;height:140px;object-fit:cover;border-radius:8px;border:1px solid #2a2a2a;">`).join('')
              }</div>`;
          }

          // Prefer FINAL TPS saved on the message… otherwise show LIVE TPS for the active stream
          let tpsTxt = '';
          if (typeof m._tps === 'number' && isFinite(m._tps)) {
            tpsTxt = ` • ${m._tps.toFixed(1)} tok/s${m._tpsIsApprox ? ' (est)' : ''}`;
          } else if (idx === lastAssistantIdx && liveTps != null) {
            tpsTxt = ` • ${liveTps.toFixed(1)} tok/s`; // live
          }

          w.innerHTML = `
      <div class="meta">${whoLabel} • ${new Date(m.ts).toLocaleTimeString()}${tpsTxt}</div>
      <div class="content">${contentHtml}</div>
      ${imagesHtml}
    `;

          frag.appendChild(w);
        });

        box.appendChild(frag);

        // run syntax highlight once after batch insert
        try { highlightIn(box); } catch { }

        // let the sticky manager decide whether to follow the bottom
        StickyScroll.onContentAppended();
      }




      function addStreamingAssistantBubble(id) {
        const s = getSession(); if (!s) return;
        const w = document.createElement('div');
        w.className = 'msg assistant';
        w.dataset.stream = '1';
        w.dataset.streamId = id; // ← NEW: let us find this bubble later
        w.innerHTML =
          `<div class="meta" id="meta-${id}">${s.model} • streaming…</div>` +
          `<div class="content" id="streamContent"></div>`;
        el('chat').appendChild(w);
        el('chat').scrollTop = el('chat').scrollHeight;
      }

      function setStreamingContent(id, text) {
        let w = document.querySelector(`.msg.assistant[data-stream-id="${id}"]`);
        let c = w && w.querySelector('#streamContent');
        if (!c) {
          addStreamingAssistantBubble(id);
          w = document.querySelector(`.msg.assistant[data-stream-id="${id}"]`);
          c = w && w.querySelector('#streamContent');
        }
        if (!c) return;
        requestAnimationFrame(() => {
          c.innerHTML = mdToHtml(text || '');
          try { highlightIn(c); } catch { }
          const container = c.closest('.chat') || c.parentElement;
          if (container && typeof container.scrollTop === 'number') container.scrollTop = container.scrollHeight;
        });
      }

      function finishStreamingBubble(id) {
        const c = el('streamContent'); if (c) { c.removeAttribute('id'); }
        const w = document.querySelector(`.msg.assistant[data-stream-id="${id}"]`) ||
          document.querySelector('.msg.assistant[data-stream="1"]');
        if (w) {
          w.dataset.stream = '0';
          _setStreamMeta(id, 'done'); // ← includes final TPS if we have it
        }
      }


      // --- System Message helpers/state ---
      const SYSTEM_GEN_PROMPT =
        "You are a system prompt generator. Given the user's description, return ONE highly detailed, actionable system prompt, with NO header explainer, or footer debrief, ONLY return the raw system prompt, Dont even label it, only the instructions that sets role, tone, constraints. Use imperative, second person. No examples unless relevant. Verbose and explicit enhancements to the provided content to ensure high quality expansion of instruction set to match determined intention.";


      /* ===== System metadata toggles (LOC / TIME / UA) ===== */
      const SYS_META_KEY = 'CLIENT_SYS_META_PREFS_V1';
      let sysMetaPrefs = loadJSON(SYS_META_KEY, { loc: false, time: false, ua: false });
      let sysMetaData = { loc: null, time: null, ua: null };

      const META_BEGIN = '[[CLIENT_META_START]]';
      const META_END = '[[CLIENT_META_END]]';

      function saveSysMetaPrefs() { saveJSON(SYS_META_KEY, sysMetaPrefs); }
      const includePhone = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 18H12.01M11 6H13M9.2 21H14.8C15.9201 21 16.4802 21 16.908 20.782C17.2843 20.5903 17.5903 20.2843 17.782 19.908C18 19.4802 18 18.9201 18 17.8V6.2C18 5.0799 18 4.51984 17.782 4.09202C17.5903 3.71569 17.2843 3.40973 16.908 3.21799C16.4802 3 15.9201 3 14.8 3H9.2C8.0799 3 7.51984 3 7.09202 3.21799C6.71569 3.40973 6.40973 3.71569 6.21799 4.09202C6 4.51984 6 5.07989 6 6.2V17.8C6 18.9201 6 19.4802 6.21799 19.908C6.40973 20.2843 6.71569 20.5903 7.09202 20.782C7.51984 21 8.07989 21 9.2 21Z" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const excludePhone = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3 3L21 21M12 18H12.01M6 6V17.8C6 18.9201 6 19.4802 6.21799 19.908C6.40973 20.2843 6.71569 20.5903 7.09202 20.782C7.51984 21 8.0799 21 9.2 21H15C15.9319 21 16.3978 21 16.7654 20.8478C17.2554 20.6448 17.6448 20.2554 17.8478 19.7654C18 19.3978 18 18.9319 18 18M8.6499 3H14.8C15.9201 3 16.4802 3 16.908 3.21799C17.2843 3.40973 17.5903 3.71569 17.782 4.09202C18 4.51984 18 5.0799 18 6.2V12.3501" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const includeLoc = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 13V7M15 10.0008L9 10M19 10.2C19 14.1764 15.5 17.4 12 21C8.5 17.4 5 14.1764 5 10.2C5 6.22355 8.13401 3 12 3C15.866 3 19 6.22355 19 10.2Z" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const excludeLoc = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 8L14 12M14 8L10 12M19 10.2C19 14.1764 15.5 17.4 12 21C8.5 17.4 5 14.1764 5 10.2C5 6.22355 8.13401 3 12 3C15.866 3 19 6.22355 19 10.2Z" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const includeTime = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 16.5V8.5M16 12.5L8 12.5008M3 5.5L5 3.5M21 5.5L19 3.5M20 12.5C20 16.9183 16.4183 20.5 12 20.5C7.58172 20.5 4 16.9183 4 12.5C4 8.08172 7.58172 4.5 12 4.5C16.4183 4.5 20 8.08172 20 12.5Z" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const excludeTime = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3 5.5L5 3.5M21 5.5L19 3.5M9 9.5L15 15.5M15 9.5L9 15.5M20 12.5C20 16.9183 16.4183 20.5 12 20.5C7.58172 20.5 4 16.9183 4 12.5C4 8.08172 7.58172 4.5 12 4.5C16.4183 4.5 20 8.08172 20 12.5Z" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      function updateSysMetaButtons() {
        const bLoc = el('sysLocBtn'), bTime = el('sysTimeBtn'), bUa = el('sysUaBtn');
        if (bLoc) { bLoc.innerHTML = sysMetaPrefs.loc ? includeLoc : excludeLoc; bLoc.classList.toggle('toggled', sysMetaPrefs.loc); }
        if (bTime) { bTime.innerHTML = sysMetaPrefs.time ? includeTime : excludeTime; bTime.classList.toggle('toggled', sysMetaPrefs.time); }
        if (bUa) { bUa.innerHTML = sysMetaPrefs.ua ? includePhone : excludePhone; bUa.classList.toggle('toggled', sysMetaPrefs.ua); }
      }

      function stripMeta(raw) {
        const s = raw || '';
        const i = s.indexOf(META_BEGIN);
        const j = s.indexOf(META_END);
        if (i !== -1 && j !== -1 && j > i) return s.slice(0, i).trimEnd();
        return s;
      }

      function captureTime() {
        const now = new Date();
        sysMetaData.time = {
          iso: now.toISOString(),
          local: now.toString(),
          tz: Intl.DateTimeFormat().resolvedOptions().timeZone || 'local',
          offset_min: -now.getTimezoneOffset()
        };
      }

      function captureUa() {
        sysMetaData.ua = {
          ua: navigator.userAgent || '',
          lang: navigator.language || '',
          platform: navigator.platform || '',
          tz: (Intl.DateTimeFormat().resolvedOptions().timeZone || ''),
          viewport: `${window.innerWidth}x${window.innerHeight}`,
          screen: (window.screen ? `${screen.width}x${screen.height}` : ''),
          dpr: (window.devicePixelRatio || 1),
          online: !!navigator.onLine
        };
      }

      function ensureLoc() {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              const c = pos.coords || {};
              sysMetaData.loc = {
                lat: Number(c.latitude?.toFixed(5)),
                lon: Number(c.longitude?.toFixed(5)),
                accuracy_m: c.accuracy != null ? Math.round(c.accuracy) : null,
                tz: Intl.DateTimeFormat().resolvedOptions().timeZone || 'local',
                source: 'browser',
                at: Date.now()
              };
              resolve();
            },
            (err) => reject(err),
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 300000 }
          );
        });
      }

      function buildMetaBlock() {
        const items = [];
        if (sysMetaPrefs.loc && sysMetaData.loc) {
          const L = sysMetaData.loc;
          items.push(`- location: lat=${L.lat}, lon=${L.lon}, accuracy_m=${L.accuracy_m}, tz=${L.tz} (source: ${L.source})`);
        }
        if (sysMetaPrefs.time) {
          if (!sysMetaData.time) captureTime();
          const T = sysMetaData.time;
          items.push(`- time: iso=${T.iso}, local="${T.local}", tz=${T.tz}, offset_min=${T.offset_min}`);
        }
        if (sysMetaPrefs.ua) {
          if (!sysMetaData.ua) captureUa();
          const U = sysMetaData.ua;
          items.push(`- client: ua="${U.ua}", lang=${U.lang}, platform=${U.platform}, viewport=${U.viewport}, screen=${U.screen}, dpr=${U.dpr}, online=${U.online}, tz=${U.tz}`);
        }
        if (!items.length) return '';
        return `${META_BEGIN}
# CLIENT_METADATA (for model guidance; safe to ignore)
${items.join('\n')}
${META_END}`;
      }

      function applySystemMeta(pushToHub = true) {
        const ta = el('systemMsg'); if (!ta) return;
        const base = stripMeta(ta.value || '');
        const meta = buildMetaBlock();
        const combined = meta ? (base.trimEnd() + '\n\n' + meta) : base;
        ta.value = combined;

        const s = getSession();
        if (s) {
          s.system = combined;
          saveJSON(STORAGE.SESS, sessions);
          if (pushToHub) sendSessionOpen(s, /*seed*/false);
        }
      }
      // Keep these to avoid breaking any assumptions elsewhere
      const sysgenPending = new Set();
      let isSysGenStreaming = false;
      let sysgenCurrentId = null;

      function toggleSystemEditor(forceOpen) {
        const wrap = el('systemEditorWrap'); if (!wrap) return;
        const toggleOut = el('systemToggleBtn');
        const toggleIn = el('systemToggleBtnInside');
        const show = forceOpen ?? wrap.classList.contains('hide'); // true = open
        if (show) {
          wrap.classList.remove('hide');
          if (toggleIn) toggleIn.classList.remove('hide');
        } else {
          wrap.classList.add('hide');
          if (toggleIn) toggleIn.classList.add('hide');
        }
      }
      const sparkle = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg">
            <path
              d="M5 16V20M6 4V8M7 18H3M8 6H4M13 4L14.7528 8.44437C14.9407 8.92083 15.0347 9.15906 15.1786 9.35994C15.3061 9.538 15.462 9.69391 15.6401 9.82143C15.8409 9.9653 16.0792 10.0593 16.5556 10.2472L21 12L16.5556 13.7528C16.0792 13.9407 15.8409 14.0347 15.6401 14.1786C15.462 14.3061 15.3061 14.462 15.1786 14.6401C15.0347 14.8409 14.9407 15.0792 14.7528 15.5556L13 20L11.2472 15.5556C11.0593 15.0792 10.9653 14.8409 10.8214 14.6401C10.6939 14.462 10.538 14.3061 10.3599 14.1786C10.1591 14.0347 9.92083 13.9407 9.44437 13.7528L5 12L9.44437 10.2472C9.92083 10.0593 10.1591 9.9653 10.3599 9.82143C10.538 9.69391 10.6939 9.538 10.8214 9.35994C10.9653 9.15906 11.0593 8.92083 11.2472 8.44437L13 4Z"
              stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
          </svg>`

      const generating = `<svg style="animation: spin 1s linear infinite;" width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3.51221C5.50442 4.74772 3 8.08143 3 12.0001C3 16.9707 7.02944 21.0001 12 21.0001C16.9706 21.0001 21 16.9707 21 12.0001C21 8.08143 18.4956 4.74772 15 3.51221" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      function setSysGenBusy(isBusy) {
        const b = el('sysGenBtn'); if (!b) return;
        b.disabled = !!isBusy;
        b.innerHTML = isBusy ? generating : sparkle;
      }

      function asHtml(html) {
        return { __html: String(html || '') };
      }


      const CONNECTING_HTML = asHtml(`<svg style="animation: spin 1s linear infinite;" width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3.51221C5.50442 4.74772 3 8.08143 3 12.0001C3 16.9707 7.02944 21.0001 12 21.0001C16.9706 21.0001 21 16.9707 21 12.0001C21 8.08143 18.4956 4.74772 15 3.51221" stroke="#ffaa00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`);


      const RECONNECTING_HTML = asHtml(`<svg style="animation: spin 1s linear infinite;" width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3.51221C5.50442 4.74772 3 8.08143 3 12.0001C3 16.9707 7.02944 21.0001 12 21.0001C16.9706 21.0001 21 16.9707 21 12.0001C21 8.08143 18.4956 4.74772 15 3.51221" stroke="#00aaff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`);

      const CONNECTFAIL_HTML = asHtml(`<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 17.0001H12.01M12 10.0001V14.0001M6.41209 21.0001H17.588C19.3696 21.0001 20.2604 21.0001 20.783 20.6254C21.2389 20.2985 21.5365 19.7951 21.6033 19.238C21.6798 18.5996 21.2505 17.819 20.3918 16.2579L14.8039 6.09805C13.8897 4.4359 13.4326 3.60482 12.8286 3.32987C12.3022 3.09024 11.6978 3.09024 11.1714 3.32987C10.5674 3.60482 10.1103 4.4359 9.19614 6.09805L3.6082 16.2579C2.74959 17.819 2.32028 18.5996 2.39677 19.238C2.46351 19.7951 2.76116 20.2985 3.21709 20.6254C3.7396 21.0001 4.63043 21.0001 6.41209 21.0001Z" stroke="#ff0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`);


      const CHECK_HTML = asHtml(`<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M21 12C21 16.9706 16.9706 21 12 21M21 12C21 7.02944 16.9706 3 12 3M21 12C21 13.6569 16.9706 15 12 15C7.02944 15 3 13.6569 3 12M21 12C21 10.3431 16.9706 9 12 9C7.02944 9 3 10.3431 3 12M12 21C7.02944 21 3 16.9706 3 12M12 21C10.3431 21 9 16.9706 9 12C9 7.02944 10.3431 3 12 3M12 21C13.6569 21 15 16.9706 15 12C15 7.02944 13.6569 3 12 3M3 12C3 7.02944 7.02944 3 12 3" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`);


      function setConn(colorOrLabel, maybeLabel) {
        const dot = el('connDot'), text = el('connText');
        if (!dot || !text) return;

        // Parse args
        let color, label, labelProvided = false;
        if (arguments.length === 1) {
          if (colorOrLabel === 'red' || colorOrLabel === 'green' || colorOrLabel === 'blue') {
            color = colorOrLabel;
          } else {
            label = colorOrLabel;
            labelProvided = true;
          }
        } else if (arguments.length >= 2) {
          color = colorOrLabel;
          label = maybeLabel;
          labelProvided = true;
        }

        // Always reset dot color to neutral (removes any default 'conn-blue')
        dot.classList.remove('conn-red', 'conn-green', 'conn-blue');

        // Apply color only if explicitly provided
        if (color === 'green' || color === 'red' || color === 'blue') {
          dot.classList.add(color === 'green' ? 'conn-green'
            : color === 'red' ? 'conn-red'
              : 'conn-blue');
        }

        // Label: hidden by default unless provided
        if (!labelProvided) {
          text.textContent = '';
          text.classList.add('hide');
        } else {
          const isHtmlObj = label && typeof label === 'object' && typeof label.__html === 'string';
          const hasLabel =
            (typeof label === 'string' && label.trim().length) ||
            (isHtmlObj && label.__html.trim().length) ||
            (label instanceof Node);

          if (hasLabel) {
            text.classList.remove('hide');
            if (label instanceof Node) {
              text.innerHTML = '';
              text.appendChild(label);
            } else if (isHtmlObj) {
              text.innerHTML = label.__html; // trusted constants only
            } else {
              text.textContent = String(label);
            }
          } else {
            text.textContent = '';
            text.classList.add('hide');
          }
        }
      }


      // ── Live net metrics (peers & latency) ─────────────────────────────────────────
      let lastPingSentAt = 0;
      let latencyMs = null;             // most recent RTT
      let latencyEwma = null;           // smoothed RTT
      const LAT_EWMA_ALPHA = 0.25;

      let latestPeersCount = null;
      let peersPollTimer = null;
      const PEERS_POLL_MS = 5000;       // ask hub every 5s for peers

      // ───────────────────── NKN peers UI (count of ready subclients) ─────────────────────
      let peersTicker = null;
      // --- Latency via stats while streaming ---
      let useStatsLatency = true;            // prefer stats-based latency during streaming
      let statsLatencyActive = false;        // toggled on llm.start/llm.done
      let lastStatsRecvAt = 0;               // when we last updated latency from stats
      const STATS_STALENESS_MS = 3000;       // if no stats for this long, allow ctrl pings again
      const LATENCY_UI_MIN_INTERVAL = 120;       // throttle UI updates
      let _lastLatencyUIAt = 0;

      function _coerceMs(t) {
        if (!Number.isFinite(t)) return null;
        // seconds → ms (handles OpenAI-style `created`, etc.)
        return (t < 1e11) ? (t * 1000) : t;
      }
      function _parseRemoteTsLike(obj) {
        if (!obj || typeof obj !== 'object') return null;

        // common keys seen in llm.stats/llm.chunk/done across backends
        const candidates = [
          obj.ts, obj.server_ts, obj.sent_at, obj.time,
          obj.created, obj.created_ms, obj.created_at, obj.timestamp, obj.server_time
        ];

        for (const v of candidates) {
          if (v == null) continue;
          if (typeof v === 'number') {
            const t = _coerceMs(v); if (t) return t;
          }
          if (typeof v === 'string') {
            const n = Number(v);
            if (Number.isFinite(n)) { const t = _coerceMs(n); if (t) return t; }
            const d = Date.parse(v);
            if (Number.isFinite(d)) return d;
          }
        }
        return null;
      }

      // Look in shallow object and a few common nested containers
      function _findRemoteTsDeep(envelope) {
        const try1 = _parseRemoteTsLike(envelope);
        if (try1) return try1;
        for (const k of ['data', 'message', 'meta', 'ollama']) {
          const t = _parseRemoteTsLike(envelope?.[k]);
          if (t) return t;
        }
        return null;
      }

      function updateLatencyFromStatsEnvelope(envelope) {
        const ts = _findRemoteTsDeep(envelope);
        if (!ts) return;

        const now = Date.now();
        const ms = Math.max(0, Math.min(90000, now - ts));

        // UI throttle
        if (now - _lastLatencyUIAt < LATENCY_UI_MIN_INTERVAL) return;
        _lastLatencyUIAt = now;

        lastStatsRecvAt = now;
        setLatencyUI(ms); // uses your EWMA + chip coloring
      }

      function _parseRemoteTs(o) {
        // accept common server timestamp keys; seconds or millis
        let t = Number(
          o?.ts ?? o?.sent_at ?? o?.server_ts ?? o?.time ??
          (o?.data && (o.data.ts ?? o.data.sent_at ?? o.data.server_ts ?? o.data.time))
        );
        if (!Number.isFinite(t)) return null;
        if (t < 1e11) t = t * 1000; // seconds → ms
        return t;
      }
      function updateLatencyFromStatsEnvelope(envelope) {
        const remoteMs = _parseRemoteTs(envelope);
        if (!remoteMs) return;
        const ms = Math.max(0, Math.min(90000, Date.now() - remoteMs));
        lastStatsRecvAt = Date.now();
        setLatencyUI(ms); // reuse your existing EWMA + coloring
      }

      function setPeersUI(n) {
        let slot = document.getElementById('peers');
        if (!slot) {
          const host = document.getElementById('statusRow') || document.querySelector('header');
          slot = document.createElement('span');
          slot.id = 'peers';
          slot.className = 'muted';
          slot.style.marginLeft = '8px';
          if (host) host.appendChild(slot);
        }
        if (n == null) { slot.textContent = ''; return; }   // ← NEW: hide when unknown
        const num = Math.max(0, Number(n) || 0);
        slot.textContent = `${num} peer${num === 1 ? '' : 's'}`;
      }

      /** Read the current number of ready subclients from MultiClient */
      function getPeerCount() {
        try { return (client && typeof client.readyClientIDs === 'function') ? client.readyClientIDs().length : 0; }
        catch { return 0; }
      }

      /** Kick a 1s ticker to keep #peers updated */
      function startPeersTicker() {
        if (peersTicker) clearInterval(peersTicker);
        peersTicker = setInterval(() => setPeersUI(getPeerCount()), 1000);
      }

      /** Stop the ticker (on fatal disconnect, page unload, etc.) */
      function stopPeersTicker() {
        if (peersTicker) { clearInterval(peersTicker); peersTicker = null; }
      }

      // ---- Continuous gradient helpers + public export ---------------------------------
      const LATENCY_STOPS = [
        { ms: 0, color: '#22c55e' }, // green
        { ms: 150, color: '#facc15' }, // yellow
        { ms: 400, color: '#ef4444' }  // red
      ];

      function _clamp(n, a, b) { return Math.min(b, Math.max(a, n)); }
      function _hexToRgb(hex) {
        const m = /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);
        if (!m) return { r: 255, g: 255, b: 255 };
        return { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) };
      }
      function _rgbToHex(r, g, b) {
        const h = (x) => x.toString(16).padStart(2, '0');
        return `#${h(r)}${h(g)}${h(b)}`;
      }
      function _lerp(a, b, t) { return a + (b - a) * t; }
      function _lerpColor(c1, c2, t) {
        const A = _hexToRgb(c1), B = _hexToRgb(c2);
        return _rgbToHex(
          Math.round(_lerp(A.r, B.r, t)),
          Math.round(_lerp(A.g, B.g, t)),
          Math.round(_lerp(A.b, B.b, t))
        );
      }

      /** Map latency (ms) to a continuous color along the configured stops */
      function colorForLatency(ms, stops = LATENCY_STOPS) {
        if (!Number.isFinite(ms)) return '#9ca3af'; // neutral gray
        const s = stops.slice().sort((a, b) => a.ms - b.ms);
        if (ms <= s[0].ms) return s[0].color;
        if (ms >= s[s.length - 1].ms) return s[s.length - 1].color;
        for (let i = 0; i < s.length - 1; i++) {
          const a = s[i], b = s[i + 1];
          if (ms >= a.ms && ms <= b.ms) {
            const t = (ms - a.ms) / (b.ms - a.ms);
            return _lerpColor(a.color, b.color, t);
          }
        }
        return s[s.length - 1].color;
      }

      /** Normalize latency to 0..1 across the first/last stops (for shaders, etc.) */
      function normalizedLatency(ms, stops = LATENCY_STOPS) {
        const min = stops[0].ms, max = stops[stops.length - 1].ms;
        return _clamp((ms - min) / (max - min), 0, 1);
      }

      // Public object for your threejs component to read/subscribe
      window.LatencyViz = window.LatencyViz || {
        lastMs: null,
        ewmaMs: null,
        color: '#9ca3af',
        norm: 0,
        stops: LATENCY_STOPS,
        colorFor: (ms) => colorForLatency(ms, LATENCY_STOPS),
        normalize: (ms) => normalizedLatency(ms, LATENCY_STOPS),
        // allow live tuning of stops
        setStops(newStops) { if (Array.isArray(newStops) && newStops.length >= 2) this.stops = newStops; }
      };
      // ----------------------------------------------------------------------------------


      // === Replace your existing setLatencyUI with this version ===
      function setLatencyUI(ms) {
        const chip = el('latent');
        if (!chip) return;

        if (!Number.isFinite(ms)) {
          chip.textContent = 'Latency';
          chip.style.borderColor = '#2a2a2a';
          chip.style.color = '';
          // expose neutral state
          window.LatencyViz.lastMs = null;
          window.LatencyViz.ewmaMs = null;
          window.LatencyViz.color = '#9ca3af';
          window.LatencyViz.norm = 0;
          window.dispatchEvent(new CustomEvent('latency:update', { detail: { ...window.LatencyViz } }));
          return;
        }

        // Smooth EWMA as before
        latencyEwma = (latencyEwma == null)
          ? ms
          : (LAT_EWMA_ALPHA * ms + (1 - LAT_EWMA_ALPHA) * latencyEwma);

        const shown = Math.max(0, Math.round(latencyEwma));

        // Continuous gradient color
        const color = colorForLatency(shown, window.LatencyViz.stops);

        // UI
        chip.textContent = `${shown} ms`;
        chip.style.borderColor = color;
        chip.style.color = color;

        // Expose to global (for threejs)
        window.LatencyViz.lastMs = ms;
        window.LatencyViz.ewmaMs = shown;
        window.LatencyViz.color = color;
        window.LatencyViz.norm = normalizedLatency(shown, window.LatencyViz.stops);

        // Notify listeners (your renderer can listen for this)
        window.dispatchEvent(new CustomEvent('latency:update', {
          detail: { ...window.LatencyViz }
        }));
      }

      // Ask the hub for its current connected clients count.
      // Your hub may answer with any of these shapes:
      //   {event:'ctrl.peers', peers:<n>}
      //   {event:'ctrl.result', kind:'peers', data:{peers|count:<n>}}
      //   {event:'ctrl.info', peers:<n>}  // occasionally broadcast by some hubs
      function requestHubPeers() {
        if (!HUB_ADDR || !client || !isConnected) return;
        const id = `peers:${Date.now()}`;
        trySend(HUB_ADDR, { event: 'ctrl.request', op: 'peers', id }, { noReply: true, msgHoldingSeconds: 120 });
      }

      // Start/stop periodic peers polling
      function startPeersPolling() {
        if (peersPollTimer) clearInterval(peersPollTimer);
        requestHubPeers();
        peersPollTimer = setInterval(requestHubPeers, PEERS_POLL_MS);
      }

      function stopPeersPolling() {
        if (peersPollTimer) { clearInterval(peersPollTimer); peersPollTimer = null; }
        setPeersUI(null);
        setLatencyUI(null);
      }


      function showModelDropdown(show) {
        const sel = el('modelSelect');
        if (!sel) return;
        sel.classList[show ? 'remove' : 'add']('hide');
        sel.disabled = !show;
      }

      // ─────────── Generic stream routing
      const ROUTES = new Map();          // reqId -> { sink:'chat'|'element'|'callback', elId?, mode?, format?, lock?, cb? }
      const streamingElements = new Set(); // element ids being streamed into (to suppress autosaves)

      function resolveEl(elOrId) { return typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId; }
      function isTextControl(el) { return !!el && ('value' in el); }
      function lockElement(el, lock = true) {
        if (!el) return;
        if ('readOnly' in el) el.readOnly = !!lock;
        if ('disabled' in el && !('readOnly' in el)) el.disabled = !!lock;
        if (el.getAttribute && el.hasAttribute('contenteditable')) {
          el.setAttribute('data-was-contenteditable', el.getAttribute('contenteditable') || 'false');
          el.setAttribute('contenteditable', lock ? 'false' : (el.getAttribute('data-was-contenteditable') || 'true'));
        }
        el.setAttribute?.('aria-busy', lock ? 'true' : 'false');
      }
      function writeToElement(el, chunk, {
        mode = 'append',      // 'append' | 'replace'
        format = 'text',      // 'text' | 'markdown'
        scroll = true,
        caretToEnd = true
      } = {}) {
        if (!el) return;
        let prev = isTextControl(el) ? (el.value || '') : (el.innerText || el.textContent || '');
        let next = (mode === 'replace') ? chunk : (prev + chunk);

        if (isTextControl(el)) {
          el.value = next;
          if (caretToEnd) {
            try { el.selectionStart = el.selectionEnd = el.value.length; } catch { }
            el.scrollTop = el.scrollHeight;
          }
        } else {
          if (format === 'markdown') {
            el.innerHTML = mdToHtml(next);
            try { highlightIn(el); } catch { }
          } else {
            el.textContent = next;
          }
          if (scroll) {
            const container = el.closest('.chat') || el.parentElement;
            if (container && typeof container.scrollTop === 'number') container.scrollTop = container.scrollHeight;
          }
        }
      }
      function registerRoute(reqId, route) { ROUTES.set(reqId, route || { sink: 'chat' }); }
      function routeFor(id) { return ROUTES.get(id) || { sink: 'chat' }; }
      function clearRoute(id) { ROUTES.delete(id); }




      function approxBytes(obj) {
        try { return new Blob([JSON.stringify(obj)]).size; }
        catch { return (JSON.stringify(obj) || '').length; }
      }
      // ── TPS helpers ──────────────────────────────────────────────────────────────
      function _num(v) { const n = Number(v); return Number.isFinite(n) ? n : null; }
      function _pick(...vals) { for (const v of vals) if (v != null) return v; return null; }

      // Accepts either a flat shape or nested {ollama|approx|stats|metrics:{...}}
      function extractTPSAndTokens(any) {
        if (!any || typeof any !== 'object') return null;

        // unwrap common wrappers
        const layers = [
          any,
          any.data,
          any.stats,
          any.metrics,
          any.ollama,
          any.approx
        ].filter(o => o && typeof o === 'object');

        let tps = null, tokens = null, approx = false;

        for (const o of layers) {
          // tokens/sec
          tps = _pick(_num(o.tps), _num(o.tokens_per_sec), _num(o.tok_per_sec), _num(o.tokps), tps);
          // token count
          tokens = _pick(_num(o.tokens), _num(o.eval_count), _num(o.output_tokens), tokens);
          if (o === any.approx) approx = true;
        }

        // Also handle Ollama's nanosecond durations if present (more reliable, final)
        // eval_count / (eval_duration_ns / 1e9)
        const evalCnt = _pick(layers[0]?.eval_count, layers[1]?.eval_count, any?.ollama?.eval_count);
        const evalDurNs = _pick(layers[0]?.eval_duration, layers[1]?.eval_duration, any?.ollama?.eval_duration);
        if (tps == null && _num(evalCnt) != null && _num(evalDurNs) != null && evalDurNs > 0) {
          tps = Number(evalCnt) / (Number(evalDurNs) / 1e9);
          approx = false; // this is authoritative
        }

        if (tps == null && tokens == null) return null;
        return { tps, tokens, approx };
      }
      // Pull TPS/tokens from many possible shapes
      function extractTPSAndTokens(src) {
        if (!src || typeof src !== 'object') return null;
        const tryNums = (...vals) => {
          for (const v of vals) {
            const n = Number(v);
            if (Number.isFinite(n)) return n;
          }
          return null;
        };
        const tps = tryNums(
          src.tps, src.tokens_per_sec, src.tok_per_sec, src.tokps,
          src.metrics && src.metrics.tps
        );
        const tokens = tryNums(
          src.tokens, src.eval_count, src.output_tokens,
          src.metrics && src.metrics.tokens
        );
        return (tps != null || tokens != null) ? { tps, tokens } : null;
      }

      // Apply stats to the in-memory record + update streaming bubble + (re)render
      function applyStreamStats(id, payload) {
        if (!id) return;
        const rec = statsByStream.get(id) || {};
        const ext =
          extractTPSAndTokens(payload) ||
          extractTPSAndTokens(payload && payload.data) ||
          extractTPSAndTokens(payload && payload.ollama);

        if (ext) {
          if (ext.tps != null) { rec.tps = ext.tps; rec.approx = false; }
          if (ext.tokens != null) rec.tokens = ext.tokens;
        } else if (rec.startAt && rec.approxTokens > 0) {
          // fallback: keep the running estimate if no explicit stats came
          const elapsed = Math.max(0.25, (Date.now() - rec.startAt) / 1000);
          rec.tps = rec.approxTokens / elapsed;
          rec.approx = true;
        }

        rec.updatedAt = Date.now();
        statsByStream.set(id, rec);

        _setStreamMeta(id, 'streaming…'); // updates bubble meta with live TPS
        renderChat();                     // <- make it visible in the message meta too
      }

      // VERY rough chars→tokens converter for live fallback between stats frames
      function estimateTokensFromText(t) {
        const len = (t || '').length;
        return Math.max(0, Math.round(len / 4)); // ~4 chars per token (tunable)
      }


      // ─────────── Outbox queue (send while connecting -> queue; flush on reconnect)
      const outbox = []; // [{ payload, route }]
      let isConnected = false, isConnecting = false;
      function requestLLM(payload, route) {
        const id = payload.id || newId('req');
        payload.id = id;
        registerRoute(id, route);

        const bytes = approxBytes(payload);
        console.groupCollapsed('%c[LLM.REQUEST]', 'color:#0af', { id, api: payload.api, stream: payload.stream, bytes });
        console.log(payload);
        console.groupEnd();

        if (!isConnected || !client) {
          outbox.push({ payload, route });
          if (route?.sink === 'element' && route.elId) {
            const n = el(route.elId);
            if (n && ('placeholder' in n)) {
              n.placeholder = (n.placeholder || '').startsWith('Queued…') ? n.placeholder : `Queued… ${n.placeholder || ''}`;
            }
          }
          console.warn('[OUTBOX] queued', { id, api: payload.api, bytes });
          return id;
        }

        trySend(HUB_ADDR, payload, { noReply: true, msgHoldingSeconds: 600 });
        return id;
      }
      function flushOutbox() {
        while (isConnected && client && outbox.length) {
          const { payload } = outbox.shift();
          console.info('[OUTBOX→SEND]', { id: payload?.id, api: payload?.api, bytes: approxBytes(payload) });
          const ok = trySend(HUB_ADDR, payload, { noReply: true, msgHoldingSeconds: 600 });
          if (!ok) {
            outbox.unshift({ payload, route: null });
            console.debug('[nkn.flush] send failed; will retry');
            return;
          }
        }
      }





      // ─────────── NKN (robust MultiClient + your message contract)
      let client = null, myAddr = null;
      let HUB_ADDR = settings.hub || '';
      let HUB_KEY = (HUB_ADDR.split('.')[1] || '').toLowerCase();   // <— NEW

      const linkConnected = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 7H16C18.7614 7 21 9.23858 21 12C21 14.7614 18.7614 17 16 17H14M10 7H8C5.23858 7 3 9.23858 3 12C3 14.7614 5.23858 17 8 17H10M8 12H16" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`

      const linkDisconnected = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 6C13.4477 6 13 6.44772 13 7C13 7.55228 13.4477 8 14 8V6ZM10 18C10.5523 18 11 17.5523 11 17C11 16.4477 10.5523 16 10 16V18ZM14 16C13.4477 16 13 16.4477 13 17C13 17.5523 13.4477 18 14 18V16ZM8 11C7.44772 11 7 11.4477 7 12C7 12.5523 7.44772 13 8 13V11ZM3.70711 2.29289C3.31658 1.90237 2.68342 1.90237 2.29289 2.29289C1.90237 2.68342 1.90237 3.31658 2.29289 3.70711L3.70711 2.29289ZM20.2929 21.7071C20.6834 22.0976 21.3166 22.0976 21.7071 21.7071C22.0976 21.3166 22.0976 20.6834 21.7071 20.2929L20.2929 21.7071ZM19.4115 14.0898C19.1224 14.5604 19.2696 15.1763 19.7402 15.4653C20.2108 15.7544 20.8266 15.6072 21.1157 15.1366L19.4115 14.0898ZM12 13C12.5523 13 13 12.5523 13 12C13 11.4477 12.5523 11 12 11V13ZM7.08376 7.08376L7.79087 6.37666L7.08376 7.08376ZM8 16C5.79086 16 4 14.2091 4 12H2C2 15.3137 4.68629 18 8 18V16ZM16 8C18.2091 8 20 9.79086 20 12H22C22 8.68629 19.3137 6 16 6V8ZM14 8H16V6H14V8ZM10 16H8V18H10V16ZM16 16H14V18H16V16ZM20 12C20 12.7678 19.7846 13.4823 19.4115 14.0898L21.1157 15.1366C21.6767 14.2232 22 13.1478 22 12H20ZM8 13H12V11H8V13ZM2.29289 3.70711L6.37666 7.79087L7.79087 6.37666L3.70711 2.29289L2.29289 3.70711ZM6.90166 6.10048C4.11245 6.61703 2 9.06076 2 12H4C4 10.0423 5.40739 8.41122 7.26586 8.06704L6.90166 6.10048ZM6.37666 7.79087L16.2091 17.6233L17.6233 16.2091L7.79087 6.37666L6.37666 7.79087ZM16.2091 17.6233L20.2929 21.7071L21.7071 20.2929L17.6233 16.2091L16.2091 17.6233ZM16.7341 15.933C16.4969 15.9769 16.2516 16 16 16V18C16.3743 18 16.7415 17.9656 17.0983 17.8995L16.7341 15.933Z" fill="#ff0000"/>
</svg>`

      const cloudUnknown = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.437 13C13.437 12 14.437 11.6046 14.437 10.5C14.437 9.39543 13.5416 8.5 12.437 8.5C11.5051 8.5 10.722 9.13739 10.5 10M12.437 16H12.447M8.4 19C5.41766 19 3 16.6044 3 13.6493C3 11.2001 4.8 8.9375 7.5 8.5C8.34694 6.48637 10.3514 5 12.6893 5C15.684 5 18.1317 7.32251 18.3 10.25C19.8893 10.9449 21 12.6503 21 14.4969C21 16.9839 18.9853 19 16.5 19L8.4 19Z" stroke="#ff0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const cloudCheck = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 13.2222L10.8462 15L15 11M8.4 19C5.41766 19 3 16.6044 3 13.6493C3 11.2001 4.8 8.9375 7.5 8.5C8.34694 6.48637 10.3514 5 12.6893 5C15.684 5 18.1317 7.32251 18.3 10.25C19.8893 10.9449 21 12.6503 21 14.4969C21 16.9839 18.9853 19 16.5 19L8.4 19Z" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const fingerPrintUnknown = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.89258 17.7897C6.9083 17.7633 6.92441 17.7369 6.9409 17.7107C8.14358 15.7988 8.8398 13.5379 8.8398 11.1034C8.8398 9.14189 10.4299 7.55176 12.3915 7.55176C14.353 7.55176 15.9431 9.14189 15.9431 11.1034C15.9431 12.0065 15.8816 12.8957 15.7626 13.7672M13.8825 19.8437C14.4257 18.7596 14.871 17.6179 15.2069 16.4309M18.6156 17.4359C19.1883 15.4236 19.4949 13.2993 19.4949 11.1033C19.4949 7.18026 16.3147 4 12.3916 4C11.0978 4 9.88477 4.34591 8.83997 4.9503M4.40039 14.9783C4.96924 13.8073 5.28831 12.4926 5.28831 11.1033C5.28831 9.8095 5.63422 8.59646 6.2386 7.55166M12.3915 11.1035C12.3915 14.2265 11.4958 17.1403 9.94727 19.6019" stroke="#ff0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
      const fingerPrint = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.89258 17.7897C6.9083 17.7633 6.92441 17.7369 6.9409 17.7107C8.14358 15.7988 8.8398 13.5379 8.8398 11.1034C8.8398 9.14189 10.4299 7.55176 12.3915 7.55176C14.353 7.55176 15.9431 9.14189 15.9431 11.1034C15.9431 12.0065 15.8816 12.8957 15.7626 13.7672M13.8825 19.8437C14.4257 18.7596 14.871 17.6179 15.2069 16.4309M18.6156 17.4359C19.1883 15.4236 19.4949 13.2993 19.4949 11.1033C19.4949 7.18026 16.3147 4 12.3916 4C11.0978 4 9.88477 4.34591 8.83997 4.9503M4.40039 14.9783C4.96924 13.8073 5.28831 12.4926 5.28831 11.1033C5.28831 9.8095 5.63422 8.59646 6.2386 7.55166M12.3915 11.1035C12.3915 14.2265 11.4958 17.1403 9.94727 19.6019" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`

      const loadingLoop = `<svg style="animation: spin 1s linear infinite;" width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3.51221C5.50442 4.74772 3 8.08143 3 12.0001C3 16.9707 7.02944 21.0001 12 21.0001C16.9706 21.0001 21 16.9707 21 12.0001C21 8.08143 18.4956 4.74772 15 3.51221" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`

      function updateChips() {
        const hasHub = !!(HUB_ADDR && isNknAddr(HUB_ADDR));
        const hasMe = !!myAddr;

        el('hubChipIcon').innerHTML = hasHub ? cloudCheck : cloudUnknown;
        el('meChipIcon').innerHTML = hasMe ? fingerPrint : fingerPrintUnknown;
        el('linkIcon').innerHTML = (hasHub && hasMe) ? linkConnected : linkDisconnected;

        el('hubChip').innerHTML = hasHub ? short(HUB_ADDR) : loadingLoop;
        el('meChip').innerHTML = hasMe ? short(myAddr) : loadingLoop;

      }

      /* ========= Soft logical channels (CTRL vs DATA) with priority & retries ========= */

      // Classify events into ctrl/data without changing callsites
      const CH = { CTRL: 'ctrl', DATA: 'data' };
      const CTRL_EVENT_RE = /^(ctrl\.|session\.|llm\.ack$|announce$|blob\.(init|ack|ready|complete|saved|ok)$)/i;
      const DATA_EVENT_RE = /^(llm\.|blob\.(part|fetch))$/i;

      function inferChannelFor(obj) {
        const ev = (obj && (obj.event || obj.api || '')) + '';
        if (CTRL_EVENT_RE.test(ev)) return CH.CTRL;
        // models list is “control plane” even if some hubs emit llm.*
        if (ev === 'llm.result' && (obj?.kind === 'models' || String(obj?.id || '').startsWith('models'))) return CH.CTRL;
        if (ev === 'models' || ev === 'ctrl.models' || ev === 'llm.models') return CH.CTRL;
        return CH.DATA;
      }

      // Transient error tester
      function isTransientSendError(e) {
        const s = (e && (e.message || e.toString())) || '';
        return /RTCDataChannel\.readyState|Message timeout|ConnectToNodeTimeoutError/i.test(s);
      }

      // Tiny prioritized mux
      const MUX = (() => {
        const q = { ctrl: [], data: [] };         // items: {addr,json,obj,opts,bytes,attempts}
        const inflight = { ctrl: 0, data: 0 };
        const LIMIT = { ctrl: 2, data: 1 };       // parallel sends per lane
        const TICK_MS = 14;                        // scheduler cadence (~60–70fps)
        const DATA_BUDGET_PER_TICK = 160 * 1024;  // soft budget to avoid WS frame bursts
        let ticker = null;

        function start() { if (!ticker) ticker = setInterval(flush, TICK_MS); }
        function stop() { if (ticker) { clearInterval(ticker); ticker = null; } }

        function enqueue(chan, addr, obj, opts) {
          // NB: we keep JSON next to the original object so logging stays one place (caller)
          const json = JSON.stringify(obj);
          const bytes = byteLenOfString(json);
          const it = { addr, obj, json, opts: { noReply: true, msgHoldingSeconds: 600, responseTimeout: 15000, ...opts }, bytes, attempts: 0 };
          (chan === CH.CTRL ? q.ctrl : q.data).push(it);
          start();
          return true;
        }

        function requeueFront(chan, it, delay = 20) {
          it.attempts++;
          setTimeout(() => (chan === CH.CTRL ? q.ctrl : q.data).unshift(it), Math.min(500, delay * (1 + Math.min(it.attempts, 10))));
        }

        function _send(chan, it) {
          inflight[chan]++;
          const p = client && client.send ? client.send(it.addr, it.json, it.opts) : Promise.reject(new Error('client not ready'));
          p.then(() => { inflight[chan]--; }).catch((e) => {
            inflight[chan]--;
            if (isTransientSendError(e) && it.attempts < 12) {
              // retry quickly; ctrl lane gets priority anyway
              requeueFront(chan, it, chan === CH.CTRL ? 20 : 40);
            } else {
              // drop silently; upstream outbox/heartbeat will recover
              if (window._PKT?.DEBUG?.ON) console.debug('[mux.drop]', { chan, err: e?.message || String(e) });
            }
          });
        }

        function flush() {
          if (!client || !isConnected) return; // keep queued until link is up
          // 1) drain CTRL first
          while (q.ctrl.length && inflight.ctrl < LIMIT.ctrl) {
            _send('ctrl', q.ctrl.shift());
          }
          // 2) then DATA under a soft budget
          let budget = DATA_BUDGET_PER_TICK;
          while (q.data.length && inflight.data < LIMIT.data && budget > 0) {
            const it = q.data[0];
            if (it.bytes > budget && inflight.data > 0) break;
            q.data.shift();
            _send('data', it);
            budget -= it.bytes;
          }
          // If queues are empty and nothing in-flight, pause the ticker
          if (!q.ctrl.length && !q.data.length && inflight.ctrl === 0 && inflight.data === 0) stop();
        }

        return {
          sendAuto(addr, obj, opts) { return enqueue(inferChannelFor(obj), addr, obj, opts); },
          sendCtrl(addr, obj, opts) { return enqueue(CH.CTRL, addr, obj, opts); },
          sendData(addr, obj, opts) { return enqueue(CH.DATA, addr, obj, opts); },
        };
      })();

      // === Replace your existing trySend() with this wrapper (same signature) ===
      function trySend(addr, obj, opts = {}) {
        if (!addr || !obj) return false;
        // One unified place to log “send” (keeps your packet console tidy)
        if (window._PKT?.DEBUG?.ON) logSendPacket(addr, obj, { noReply: true, msgHoldingSeconds: 600, responseTimeout: 15000, ...opts });
        return MUX.sendAuto(addr, obj, opts);
      }

      // Optional helpers if you want to be explicit in a few places:
      const sendCtrl = (addr, obj, opts) => MUX.sendCtrl(addr, obj, opts);
      const sendData = (addr, obj, opts) => MUX.sendData(addr, obj, opts);
      /* ========= /Soft logical channels ========= */



      // Streaming (ordered)
      const streams = new Map();
      let currentStreamId = null;
      let pendingStreamId = null;
      let isStreaming = false;
      const cancelledStreams = new Set();
      // ── Per-stream live metrics (TPS, tokens) ─────────────────────────────
      const statsByStream = new Map(); // id -> { tps, tokens, updatedAt }
      function _setStreamMeta(id, phase /* 'streaming…' | 'done' */) {
        const s = getSession() || {};
        const meta =
          document.getElementById(`meta-${id}`) ||
          document.querySelector(`.msg.assistant[data-stream-id="${id}"] .meta`);
        if (!meta) return;
        const st = statsByStream.get(id);
        const tpsTxt = (st && Number.isFinite(st.tps)) ? ` • ${st.tps.toFixed(1)} tok/s${st.approx ? ' (est)' : ''}` : '';
        meta.textContent = `${s.model || 'assistant'} • ${phase}${tpsTxt}`;
      }


      // ── Image attachments (pending for the next user message) ────────────
      let pendingImages = []; // [{ name, size, type, dataURL }]

      function setAttachProgress(blobId, pct) {
        const i = pendingImages.findIndex(x => x.blobId === blobId);
        if (i !== -1) {
          pendingImages[i].pct = Math.max(0, Math.min(100, pct | 0));
          renderAttachments();
        }
      }

      function renderAttachments() {
        const wrap = el('attachPreview'); if (!wrap) return;
        wrap.innerHTML = '';
        for (let i = 0; i < pendingImages.length; i++) {
          const p = pendingImages[i];
          const up = p.blobId ? uploads.get(p.blobId) : null;
          const isUploading = !!up?.uploading;
          const isDone = !!up?.done;
          const badgeText = isDone ? 'ready' : (isUploading ? ((p.pct || 0) + '%') : 'staged'); // ← NEW

          const div = document.createElement('div');
          div.className = 'thumb';
          div.style.position = 'relative';
          div.innerHTML = `
      <img src="${p.dataURL}" alt="">
      <div class="x" title="Remove">×</div>
      ${p.big ? `
        <div class="bar" style="position:absolute;left:0;right:0;bottom:0;height:4px;background:#2a2a2a;border-radius:0 0 8px 8px;overflow:hidden;">
          <div style="height:100%;width:${isUploading ? (p.pct || 0) : 0}%;background:#0a84ff;transition:width .2s;"></div>
        </div>
        <div class="badge" style="position:absolute;top:6px;left:6px;background:rgba(0,0,0,.55);padding:2px 6px;border-radius:6px;font-size:12px;border:1px solid #2a2a2a;">
          ${badgeText}
        </div>` : ''}
    `;
          div.querySelector('.x').onclick = () => { pendingImages.splice(i, 1); renderAttachments(); };
          wrap.appendChild(div);
        }
        wrap.style.display = pendingImages.length ? 'flex' : '';
      }

      // Show/Hide the attach button based on model capability
      function toggleImageAttach(supported) {
        const btn = el('attachBtn');
        if (!btn) return;
        btn.style.display = supported ? 'flex' : 'none';
        if (!supported) {
          pendingImages = [];
          renderAttachments();
        }
      }


      function startStream(id, onChunk) { streams.set(id, { next: 1, lastAck: 0, buffer: new Map(), onChunk }); }
      // capture tool calls per stream id
      const toolCallsByStream = new Map(); // id -> [{ name, arguments, raw }]

      function handleChunk(id, seq, data) {
        if (cancelledStreams.has(id)) return;
        const st = streams.get(id); if (!st) return;

        // stash and drain in order, same as before
        st.buffer.set(seq, data);
        if (!isStreaming && currentStreamId === null && pendingStreamId === id) { setStopMode(id); }

        // peek for tool_calls in this part (Ollama emits under data.message.tool_calls)
        try {
          const msg = data && data.message;
          if (msg && Array.isArray(msg.tool_calls) && msg.tool_calls.length) {
            const list = toolCallsByStream.get(id) || [];
            for (const tc of msg.tool_calls) {
              const fn = tc && tc.function || {};
              list.push({
                name: String(fn.name || ''),
                arguments: (fn.arguments ?? {}),
                raw: tc
              });
            }
            toolCallsByStream.set(id, list);
          }
        } catch { /* tolerate shape drift */ }

        while (st.buffer.has(st.next)) {
          const part = st.buffer.get(st.next);
          st.buffer.delete(st.next);

          const txt = extractDelta(part) || '';
          if (txt) {
            const rec = statsByStream.get(id) || { startAt: Date.now(), approxTokens: 0, approx: true };
            rec.approxTokens = (rec.approxTokens || 0) + estimateTokensFromText(txt);
            const elapsed = Math.max(0.25, (Date.now() - (rec.startAt || Date.now())) / 1000);
            rec.tps = rec.approxTokens > 0 ? (rec.approxTokens / elapsed) : rec.tps;
            rec.tokens = Math.max(rec.tokens || 0, rec.approxTokens || 0);
            rec.updatedAt = Date.now();
            statsByStream.set(id, rec);
            _setStreamMeta(id, 'streaming…'); // updates bubble header immediately
          }


          st.onChunk(part);
          st.next++;
        }
        renderChat();
        sendAck(id, st.next - 1);
      }
      /* ========= Coalesced ACKs for streams ========= */
      const ACK_FLUSH_MS = 80;  // coalesce within this window
      const _ackBucket = new Map(); // id -> upto
      let _ackTimer = null;

      function flushAcksNow() {
        _ackTimer = null;
        if (!_ackBucket.size || !HUB_ADDR) return;
        for (const [id, upto] of _ackBucket.entries()) {
          // ACKs are control-plane; they ride the CTRL lane
          sendCtrl(HUB_ADDR, { event: 'llm.ack', id, upto }, { noReply: true, msgHoldingSeconds: 120 });
        }
        _ackBucket.clear();
      }

      // Drop-in replacement
      function sendAck(id, upto) {
        if (!id || !(upto >= 0)) return;
        const prev = _ackBucket.get(id) ?? -1;
        if (upto > prev) _ackBucket.set(id, upto);
        if (!_ackTimer) _ackTimer = setTimeout(flushAcksNow, ACK_FLUSH_MS);
      }
      /* ========= /Coalesced ACKs ========= */

      function endStream(id) { streams.delete(id); cancelledStreams.delete(id); if (currentStreamId === id) currentStreamId = null; if (pendingStreamId === id) pendingStreamId = null; }

      // Models
      let modelsLoaded = false;
      let modelRevealTimer = null;
      let clearLabelTimer = null;
      let modelsRetryTimer = null;
      let modelsRetryBackoff = 800;        // grows up to MODELS_MAX_BACKOFF_MS
      const MODELS_MAX_BACKOFF_MS = 1500;

      let modelsInFlight = false;
      let availableModels = [];            // canonical, de-duped, normalized names

      // Correlation & observability
      let lastModelsReqId = null;          // 'models:<nonce>'
      let modelsLastSeenAt = 0;            // ms
      let modelsSeenThisSession = 0;       // count of successful updates this page load


      function setModelsUIState(ready) {
        const sel = el('modelSelect');
        const newBtn = el('newSessionBtn');
        if (sel) sel.disabled = !ready;
        if (newBtn) newBtn.disabled = !ready;
      }

      function isValidModelName(name) {
        if (!name || typeof name !== 'string') return false;
        const v = name.trim();
        if (!v) return false;
        // Disallow any placeholder labels you use
        const bad = [
          'Loading Models', 'Loading Models…',
          '— no models —', '— timed out fetching models —',
          '— no models (hub error) —'
        ];
        if (bad.some(b => v.startsWith(b))) return false;
        // Must exist in the loaded list
        return availableModels.includes(v);
      }

      function showModelsError(msg) {
        const sel = el('modelSelect'); if (!sel) return;
        sel.innerHTML = '';
        const opt = document.createElement('option');
        opt.textContent = msg || '— no models —';
        sel.appendChild(opt);

        modelsInFlight = false;
        modelsLoaded = false;
        availableModels = [];
        setModelsUIState(false);
        showModelDropdown(true);
      }

      function requestModelsList(force = false) {
        if (!HUB_ADDR || !client || !isConnected) return;
        if (modelsInFlight && !force) return;  // ← short-circuit duplicates
        modelsInFlight = true;                 // ← set early

        const nonce = Date.now();
        lastModelsReqId = `models:${nonce}`;
        trySend(HUB_ADDR, { event: 'llm.request', id: lastModelsReqId, api: 'list', stream: false });
        trySend(HUB_ADDR, { event: 'ctrl.request', op: 'models', id: lastModelsReqId });
      }



      function populateModels(modelsLike) {
        const sel = el('modelSelect'); if (!sel) return;

        // Normalize: accept {models:[{model|name|digest|id|string}...]}, or bare array, or {data:{models:[...]}}
        const arr = (() => {
          const d = modelsLike;
          if (Array.isArray(d)) return d;

          if (d && typeof d === 'object') {
            if (Array.isArray(d.models)) return d.models;
            if (d.data && Array.isArray(d.data.models)) return d.data.models;

            // ← NEW: accept {list:[...]} or {data:{list:[...]}}
            if (Array.isArray(d.list)) return d.list;
            if (d.data && Array.isArray(d.data.list)) return d.data.list;

            // ← NEW: accept {data:[...]} as a last resort
            if (Array.isArray(d.data)) return d.data;
          }
          return [];
        })();

        const names = Array.from(new Set(arr.map((m) => {
          if (!m) return '';
          if (typeof m === 'string') return m.trim();
          if (typeof m === 'object') return (m.model || m.name || m.id || m.digest || '').trim();
          return '';
        }).filter(Boolean)));

        // Update globals
        availableModels = names.slice();
        modelsLoaded = availableModels.length > 0;
        modelsLastSeenAt = Date.now();
        if (modelsLoaded) modelsSeenThisSession++;

        // Rebuild UI
        sel.innerHTML = '';
        if (modelsLoaded) {
          for (const name of availableModels) {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            sel.appendChild(opt);
          }
        } else {
          const opt = document.createElement('option');
          opt.textContent = '— no models —';
          sel.appendChild(opt);
        }

        setModelsUIState(modelsLoaded);

        // Restore remembered value only if valid
        const remembered = getSavedModel();
        if (remembered && isValidModelName(remembered)) {
          sel.value = remembered;
        } else if (modelsLoaded && sel.options.length) {
          sel.value = sel.options[0].value;
        }

        // NEW: fetch details for the currently selected model
        if (sel.value && isValidModelName(sel.value)) {
          updateModelInfo(sel.value);
        }


        // Creating a session is only allowed when the selection is valid.
        sel.onchange = () => {
          const model = sel.value;
          if (isValidModelName(model)) {
            setSavedModel(model);
            updateModelInfo(model);       // ← NEW: fetch and render model details
            createSessionForModel(model);
          } else if (availableModels[0]) {
            sel.value = availableModels[0];
          }
        };

        showModelDropdown(true);
      }

      // ── Model "show" helpers ─────────────────────────────────────────────
      function /*seed*/normalizeModelShow(model, raw) {
        const data = raw || {};
        const det = data.details || {};
        const mi = data.modelinfo || {};

        // parse "parameters" string like: "top_p 0.95\nstop \"\"\ntemperature 1\ntop_k 64"
        const paramsObj = {};
        if (typeof data.parameters === 'string') {
          data.parameters.split(/\n+/).forEach(line => {
            const m = line.match(/^\s*([A-Za-z0-9_]+)\s+(.+?)\s*$/);
            if (m) paramsObj[m[1]] = m[2];
          });
        }
        const paramNum = (k) => {
          const v = paramsObj[k];
          const n = Number(v);
          return Number.isFinite(n) ? n : null;
        };

        // prefer raw capabilities array verbatim
        const capabilities = Array.isArray(data.capabilities) ? data.capabilities.map(String) : [];

        // try to pull context length from modelinfo (e.g. "gemma3.context_length": 131072)
        const ctxFromModelInfo = (() => {
          if (!mi || typeof mi !== 'object') return null;
          for (const [k, v] of Object.entries(mi)) {
            if (/context_length$/i.test(k)) {
              const n = Number(v);
              if (Number.isFinite(n)) return n;
            }
          }
          return null;
        })();

        return {
          name: data.model || model,
          modified_at: data.modified_at || null,
          format: det.format || null,
          family: det.family || null,
          families: Array.isArray(det.families) ? det.families : (det.family ? [det.family] : []),
          parameter_size: det.parameter_size || null,
          quantization: det.quantization || det.quantization_level || null,
          num_ctx: ctxFromModelInfo || paramNum('num_ctx') || det.num_ctx || null,
          license: data.license || null,
          capabilities,          // ← raw, unmodified
          raw: data,
        };
      }


      function renderModelInfo(info) {
        const row = el('modelCaps'); if (!row) return;

        const esc = (s) => String(s).replace(/[&<>"']/g, m =>
          m === '&' ? '&amp;' : m === '<' ? '&lt;' : m === '>' ? '&gt;' : m === '"' ? '&quot;' : '&#39;'
        );

        const chips = [];

        // RAW capabilities from model file
        if (Array.isArray(info.capabilities) && info.capabilities.length) {
          for (const c of info.capabilities) chips.push(`<div class="chip">${esc(c)}</div>`);
        } else {
          chips.push('<div class="chip">Capabilities: —</div>');
        }

        // Meta chips (from details/modelinfo where available)
        if (info.format) chips.push(`<div class="chip">${esc(info.format)}</div>`);
        if (info.parameter_size) chips.push(`<div class="chip">${esc(info.parameter_size)}</div>`);
        if (info.quantization) chips.push(`<div class="chip">${esc(info.quantization)}</div>`);
        if (info.num_ctx) chips.push(`<div class="chip">${esc(info.num_ctx)}</div>`);

        row.innerHTML = chips.join(' ');
      }


      function fetchModelInfo(model, cb) {
        if (!model) { cb && cb({ ok: false, error: 'missing model' }); return; }
        const id = `show:${model}:${Date.now()}`;
        registerRoute(id, { sink: 'callback', cb });
        requestLLM({
          event: 'llm.request',
          id,
          api: 'show',
          model,
          stream: false
        });
      }

      function resumeAllUploads() {
        for (const [id, up] of uploads.entries()) {
          if (!up || up.done || !up.uploading) continue; // ← only resume active ones
          trySend(HUB_ADDR, {
            event: 'blob.init',
            id,
            name: up.name,
            mime: up.mime,
            size: up.size,
            chunkSize: up.chunkSize,
            total: up.total
          });
          setTimeout(() => pumpBlob(id), 0);
        }
      }



      function updateModelInfo(model) {
        const row = el('modelCaps');
        if (row) { row.style.display = 'flex'; row.innerHTML = ''; }

        // 1) Fast path: render from cache immediately if present
        const hadCache = tryRenderModelInfoFromCache(model);

        // 2) Always attempt a fresh fetch (keeps cache current when chosen from dropdown)
        fetchModelInfo(model, (res) => {
          if (!res?.ok) { return; }
          const data = (res.body && (res.body.data || res.body)) || {};
          const info = normalizeModelShow(model, data);

          // render (may overwrite cached UI with fresher values)
          renderModelInfo(info);
          const hasVision = Array.isArray(info.capabilities) && info.capabilities.some(c => String(c).toLowerCase() === 'vision');
          toggleImageAttach(!!hasVision);

          // cache for later session switches
          cacheSetModelInfo(model, info);

          console.log('[model.show]', { model, info, source: hadCache ? 'cache→refreshed' : 'fresh' });
        });
      }



      // Build history for seeding (exclude 'system'; it's sent separately)
      function buildHistoryForSession(sess) {
        const HISTORY_SEED_LIMIT = 16;         // max messages to seed
        const HISTORY_CHAR_BUDGET = 24 * 1024; // ~24 KB of text total

        const src = (sess?.messages || []);
        const out = [];
        let used = 0;

        // walk from newest to oldest, then unshift to keep order
        for (let i = src.length - 1; i >= 0 && out.length < HISTORY_SEED_LIMIT; i--) {
          const m = src[i];
          const role = (m.role === 'user' || m.role === 'assistant' || m.role === 'system') ? m.role : 'assistant';
          const content = String(m.content || '');
          // images are never seeded; content only
          if (used + content.length > HISTORY_CHAR_BUDGET) break;
          used += content.length;
          out.unshift({ role, content });
        }
        return out;
      }

      // Session control → hub
      function currentOptions() { return { temperature: settings.temperature, top_p: settings.top_p, seed: settings.seed, num_ctx: settings.num_ctx }; }
      function sendSessionOpen(s, seed) {
        if (!s || !HUB_ADDR) return;
        const payload = {
          event: 'session.open',
          sid: s.id,
          model: s.model || undefined,
          system: (s.system || ''),
          options: currentOptions()
        };
        if (seed) { payload.history = buildHistoryForSession(s); payload.replace = true; }
        trySend(HUB_ADDR, payload);
      }
      function sendSessionReset(sid) { if (!sid || !HUB_ADDR) return; trySend(HUB_ADDR, { event: 'session.reset', sid }); }

      // Back off: let the SDK handle path rotation & reconnects.
      // We only intervene if we miss multiple pongs *and* all subclients are 0 for a while.
      const HEARTBEAT_MS = 100;                // ping every 6s (tolerant of timer clamping)
      const MISSED_PONG_LIMIT = 4;              // ~24s of missed pongs before we consider action
      const PEERS_ZERO_GRACE_MS = 12000;        // require peers==0 for at least 12s too
      let hbTimer = null;
      let lastPongAt = 0; 
      let missedPongs = 0;
      let peersZeroSince = 0;

      function startHeartbeat() {
        if (hbTimer) clearInterval(hbTimer);

        // Prime one ping immediately on start
        try {
          lastPingSentAt = Date.now();
          sendCtrl(HUB_ADDR, { event: 'ctrl.ping', ts: lastPingSentAt }, { noReply: true, maxHoldingSeconds: 120 });
        } catch { }

        hbTimer = setInterval(() => {
          if (!HUB_ADDR) return;

          // If we don't have a client, build one.
          if (!client && !isConnecting) {
            setConn(RECONNECTING_HTML);
            connectNKN();
            return;
          }

          // Quiet pings while streaming if stats are fresh; fallback if stats go stale.
          const statsFresh = (useStatsLatency && statsLatencyActive && (Date.now() - lastStatsRecvAt) < STATS_STALENESS_MS);
          if (!statsFresh) {
            lastPingSentAt = Date.now();
            sendCtrl(HUB_ADDR, { event: 'ctrl.ping', ts: lastPingSentAt }, { noReply: true, maxHoldingSeconds: 120 });
          }


          const now = Date.now();
          const sincePong = now - (lastPongAt || 0);

          // Track missed pongs & peers==0 window
          if (sincePong > HEARTBEAT_MS * 2) missedPongs++; else missedPongs = 0;

          const peersNow = getPeerCount();
          if (peersNow === 0) {
            if (!peersZeroSince) peersZeroSince = now;
          } else {
            peersZeroSince = 0;
          }

          // Only do a hard rebuild if the link truly looks wedged.
          if (!isConnecting && missedPongs >= MISSED_PONG_LIMIT && peersZeroSince && (now - peersZeroSince) >= PEERS_ZERO_GRACE_MS) {
            try { client && client.close && client.close(); } catch { }
            client = null;
            isConnected = false;
            setConn(RECONNECTING_HTML);
            connectNKN();
          }
        }, HEARTBEAT_MS);
      }


      document.addEventListener('dblclick', function (e) {
        e.preventDefault();
      });

      document.addEventListener('touchmove', function (event) {
        // Check if there are two or more touch points
        if (event.touches.length > 1) {
          event.preventDefault(); // Stop the browser from zooming
        }
      }, { passive: false });

      window.addEventListener('unhandledrejection', (e) => {
        const s = String(e.reason && e.reason.message || e.reason || '');
        if (/RTCDataChannel\.readyState|Message timeout|ConnectToNodeTimeoutError/i.test(s)) {
          e.preventDefault();
          console.debug('[nkn] suppressed transient send error:', s);
        }
      });

      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          const stale = missedPongs >= MISSED_PONG_LIMIT;  // align with the new policy
          if ((!client || stale) && !isConnecting) connectNKN();
          else if (isConnected && !modelsLoaded && !modelsInFlight) requestModelsList(true);
        }
      });


      // LTE-proven NKN connect: minimal, robust for 5G/CGNAT
      function connectNKN() {
        if (isConnecting) return;
        if (!isNknAddr(HUB_ADDR)) { openSettings(); return; }

        isConnecting = true;
        isConnected = false;
        updateChips();


        setConn(CONNECTING_HTML);

        try { if (client) { try { client.close(); } catch { } } } catch { }

        client = new nkn.MultiClient({
          seed: getOrCreateSeed(),
          identifier: 'web',
          numSubClients: Math.max(1, Math.min(12, Number(settings.peers) || 4)),
          originalClient: true,
          responseTimeout: 15000,
          msgHoldingSeconds: 600,

          // Tolerate mobile timer clamping & transient WS flaps on the browser side
          wsConnHeartbeatTimeout: 120000,  // 120s (mirrors your hub)
          reconnectIntervalMin: 1000,
          reconnectIntervalMax: 10000,
          connectTimeout: 15000,
          // Optionally: pin to WS seed nodes you trust
          // seedWsAddr: ['wss://<seed-1>', 'wss://<seed-2>'],
        });


        client.onConnect(() => {
          isConnecting = false;
          isConnected = true;
          setPeersUI(getPeerCount());
          startPeersTicker();
          setConn(CHECK_HTML);
          myAddr = client.addr; updateChips();
          lastPongAt = Date.now();
          startHeartbeat();
          startPeersPolling();     // ← NEW
          setLatencyUI(null);      // reset visible chip on fresh connect
          setPeersUI(null);


          trySend(HUB_ADDR, { event: 'announce' }, { noReply: true, msgHoldingSeconds: 600 });

          const s = getSession();
          if (s) { setSavedModel(s.model || getSavedModel()); sendSessionOpen(s, /*seed*/false); }
          resumeAllUploads();                 // NEW
          flushOutbox();

          // Kick models fetch now that we're definitely connected
          requestModelsList(true);
          setTimeout(() => {
            if (!modelsLoaded && !modelsInFlight) requestModelsList(true);
          }, 2500);
        });

        // One message funnel; onInbound will filter to the configured hub
        client.on('message', onInbound);

        client.on('willreconnect', () => {
          isConnecting = false;
          isConnected = false;
          // Keep the previous peers display; MultiClient will repopulate shortly.
          stopPeersPolling();
          setLatencyUI(null);
          setConn(RECONNECTING_HTML);
        });

        client.on('connectFailed', () => {
          isConnecting = false;
          isConnected = false;
          setPeersUI(0);
          stopPeersTicker();
          setConn(CONNECTFAIL_HTML);
          setTimeout(connectNKN, 1200 + Math.random() * 600); // jittered retry
        });
        client.on('close', () => {
          isConnecting = false;
          isConnected = false;
          setPeersUI(0);
          stopPeersTicker();
          setConn('red', 'Disconnected');
          setTimeout(connectNKN, 1200 + Math.random() * 600);
        });
        client.on('error', () => {
          isConnecting = false;
          isConnected = false;
          setPeersUI(0);
          setConn('red', 'Error');
          // Heartbeat loop will attempt reconnect when stale
        });

        window.addEventListener('beforeunload', () => { try { client && client.close(); } catch { } });
      }


      function decodePayload(payload) {
        const tryParse = (s) => {
          try { return JSON.parse(s); } catch { return null; }
        };
        try {
          // Uint8Array / ArrayBuffer / DataView
          if (payload instanceof Uint8Array) {
            const s = new TextDecoder().decode(payload);
            const obj = tryParse(s);
            return obj || { raw: s };
          }
          if (payload instanceof ArrayBuffer) {
            const s = new TextDecoder().decode(new Uint8Array(payload));
            const obj = tryParse(s);
            return obj || { raw: s };
          }
          if (payload instanceof DataView) {
            const u8 = new Uint8Array(payload.buffer, payload.byteOffset, payload.byteLength);
            const s = new TextDecoder().decode(u8);
            const obj = tryParse(s);
            return obj || { raw: s };
          }

          if (typeof payload === 'string') {
            // Handle double-JSON (some bridges serialize twice)
            const once = tryParse(payload);
            if (!once) return null;
            if (typeof once === 'string') {
              const twice = tryParse(once);
              return twice || { raw: once };
            }
            return once;
          }

          if (payload && typeof payload === 'object') {
            // Some bridges wrap as { payload: "<json-string>" }
            if (typeof payload.payload === 'string') {
              const inner = tryParse(payload.payload);
              if (inner) return inner;
            }
            return payload;
          }
        } catch { }
        return null;
      }
      /* ========= Inbound demux: CTRL vs DATA ========= */

      // Trust gate helper (same rule you had, kept intact)
      function _sameHubOrTrusted(ev, srcStr) {
        const fromKey = (String(srcStr || '').split('.')[1] || '').toLowerCase();
        if (HUB_KEY && fromKey && fromKey !== HUB_KEY) {
          if (DEBUG.ON) {
            if (!_sameHubOrTrusted._lastKeyWarnAt || Date.now() - _sameHubOrTrusted._lastKeyWarnAt > 60000) {
              console.warn('[inbound] src key mismatch (debug mode, accepting)', { ev, src: srcStr, expectedKey: HUB_KEY });
              _sameHubOrTrusted._lastKeyWarnAt = Date.now();
            }
            return true;
          }
          return false; // production: drop mismatched hub frames
        }
        return true;
      }


      function isModelsPayload(ev, body) {
        return ev === 'llm.models' || ev === 'ctrl.models' || ev === 'models' ||
          (ev === 'llm.result' && (body?.kind === 'models' || String(body?.id || '').startsWith('models'))) ||
          (ev === 'ctrl.result' && (body?.kind === 'models' || String(body?.id || '').startsWith('models'))) ||
          (!ev && looksLikeModels(body));
      }

      /* ----- CTRL handler (pongs, models, session/meta, blob control, errors) ----- */
      function onInboundCtrl(ev, body, srcStr) {
        // Blob control
        if (ev === 'blob.accept') {
          const id = body.id, up = uploads.get(id); if (!up) return true;
          if (up.acceptWatch) { clearTimeout(up.acceptWatch); up.acceptWatch = null; }
          clearTimeout(up.noAckTimer);
          up.noAckMode = false;
          // ⚠️ Do NOT clear inflight here; acks for pre-accept parts may still arrive
          if (typeof body.resumeFrom === 'number' && body.resumeFrom > 0) {
            up.nextSeq = Math.min(body.resumeFrom, up.total);
            // Mark everything before resumeFrom as acked for progress
            for (let s = 0; s < up.nextSeq; s++) up.acked.add(s);
            setAttachProgress(id, Math.floor((up.nextSeq / up.total) * 100));
          }
          pumpBlob(id);
          return true;
        } if (ev === 'blob.ack') {
          const id = body.id;
          const up = uploads.get(id);
          if (!up) return true;

          if (up.acceptWatch) { clearTimeout(up.acceptWatch); up.acceptWatch = null; }
          clearTimeout(up.noAckTimer);
          up.noAckMode = false;

          // Per-chunk ACK
          if (typeof body.seq === 'number') {
            const seq = body.seq | 0;
            if (seq >= 0) {
              if (up.inflight.has(seq)) up.inflight.delete(seq);
              up.acked.add(seq);                  // always count progress
              const t0 = up['t' + seq];
              if (t0) {
                const rtt = Date.now() - t0;
                up.rtts.push(rtt); if (up.rtts.length > 8) up.rtts.shift();
                const avg = up.rtts.reduce((a, b) => a + b, 0) / up.rtts.length;
                if (avg < 180 && BLOB_WINDOW < 2) BLOB_WINDOW = 2;
                else if (avg > 600 && BLOB_WINDOW > 1) BLOB_WINDOW = 1;
              }
              setAttachProgress(id, Math.floor((up.acked.size / up.total) * 100));
            }
          }

          // Range ACK
          if (typeof body.upto === 'number') {
            const upto = Math.min(body.upto | 0, up.total - 1);
            for (const s of Array.from(up.inflight)) if (s <= upto) up.inflight.delete(s);
            for (let s = 0; s <= upto; s++) up.acked.add(s);
            setAttachProgress(id, Math.floor(((upto + 1) / up.total) * 100));
          }

          pumpBlob(id);
          return true;
        }

        // Accept stats on control plane too (if backend emits `ctrl.stats` or `session.stats`)
        if (ev === 'llm.stats' || ev === 'ctrl.stats' || ev === 'session.stats') {
          const id = body.id;
          if (id) applyStreamStats(id, body);  // <- updates store + re-renders
          return true;
        }

        if (ev === 'blob.ready' || ev === 'blob.complete' || ev === 'blob.saved' || ev === 'blob.ok') {
          const id = body.id, ref = body.ref || body.url || body.key || body.path, up = uploads.get(id);
          if (up) {
            if (up.acceptWatch) { clearTimeout(up.acceptWatch); up.acceptWatch = null; }
            clearTimeout(up.noAckTimer);
            if (up.doneTicker) { clearInterval(up.doneTicker); up.doneTicker = null; }
            up.done = true; up.uploading = false; up.staged = false; up.readyRef = ref || up.readyRef;
            if (up.readyRef) pendingBlobRefs.push(up.readyRef);
            setAttachProgress(id, 100);
            if (typeof up._resolveReady === 'function') { try { up._resolveReady(up.readyRef); } catch { } up._resolveReady = null; }
            const idx = pendingImages.findIndex(x => x.blobId === id);
            if (idx !== -1) pendingImages[idx].ready = true;
          }
          return true;
        }

        // Heartbeat / peers / latency
        if (ev === 'ctrl.pong') {
          const now = Date.now();
          lastPongAt = now;
          setPeersUI(getPeerCount());

          const sentTs = (typeof body?.ts === 'number') ? body.ts : lastPingSentAt;
          const rtt = Number.isFinite(sentTs) ? Math.max(0, Math.min(90000, now - sentTs)) : null;
          if (Number.isFinite(rtt)) { latencyMs = rtt; setLatencyUI(rtt); } else { setLatencyUI(null); }

          // let hub supply its view if present
          const peers = (typeof body?.peers === 'number') ? body.peers
            : (typeof body?.peer_count === 'number') ? body.peer_count
              : (Array.isArray(body?.subs) ? body.subs.length : null);
          if (peers != null) setPeersUI(peers);

          setConn('green', '');
          if (!modelsLoaded) requestModelsList(true);
          return true;
        }

        // Models list (regardless of exact envelope)
        if (isModelsPayload(ev, body)) {
          modelsInFlight = false;
          if (modelsRetryTimer) clearTimeout(modelsRetryTimer);
          modelsRetryBackoff = 800;
          const payload = body?.data ?? body;
          populateModels(payload);
          return true;
        }

        // Informational / errors
        if (ev === 'session.ready' || ev === 'session.info') {
          const s = getSession();
          // if hub indicates a cold/missing session, seed once with history
          if (s && (body?.cold || body?.need_seed || body?.empty || body?.replace)) {
            sendSessionOpen(s, /*seed*/true);
          } else if (s) {
            // remember that remote side is warm (persisting is fine; it’s just a small flag)
            s._remoteReady = true; saveJSON(STORAGE.SESS, sessions);
          }
          return true;
        }
        if (ev === 'ctrl.error') {
          console.warn('[ctrl.error]', body);
          if (/\bsession\b/i.test(String(body?.message || ''))) {
            const s = getSession(); if (s) sendSessionOpen(s, /*seed*/true);
          }
          return true;
        }

        // Not handled here
        return false;
      }

      /* ----- DATA handler (llm streams/results/errors unrelated to models) ----- */
      function onInboundData(ev, body, srcStr) {
        const route = routeFor(body.id);

        if (ev === 'llm.start') {
          const { id, stream } = body;
          console.info('[llm.start]', { id, stream });
          // init record for this stream (add timing fields for fallback estimates)
          statsByStream.set(id, {
            tps: null,
            tokens: 0,
            updatedAt: Date.now(),
            startAt: Date.now(),   // <— for live TPS estimate
            approxTokens: 0,       // <— running token est (chars→tokens)
            approx: true
          });

          statsLatencyActive = true;          // ← NEW
          lastStatsRecvAt = Date.now();       // ← NEW
          updateLatencyFromStatsEnvelope(body); // optional prime if server sent a ts

          if (route.sink === 'element') {
            const elx = resolveEl(route.elId);
            if (route.lock) lockElement(elx, true);
            if (route.elId) streamingElements.add(route.elId);
            isSysGenStreaming = true; sysgenCurrentId = id;

            pendingStreamId = id;
            setStopMode(id);

            let first = true;
            startStream(id, (part) => {
              const t = extractDelta(part); if (!t) return;
              writeToElement(elx, t, {
                mode: first && route.mode === 'replace' ? 'replace' : 'append',
                format: route.format || 'text',
                scroll: true, caretToEnd: true
              });
              first = false;
            });
            return true;
          }

          if (stream) {
            pendingStreamId = id;
            addStreamingAssistantBubble(id);
            const sess = getSession(); if (!sess) return true;
            sess.messages.push({ role: 'assistant', content: '', ts: Date.now() });
            saveJSON(STORAGE.SESS, sessions);
            let acc = '';
            startStream(id, (part) => {
              const text = extractDelta(part);
              if (text) { acc += text; setStreamingContent(id, acc); updateLastAssistantContent(sess.id, acc); }
            });

          }

          return true;
        }

        if (ev === 'llm.stats') {
          applyStreamStats(body.id, body);   // same sink
          if (useStatsLatency && statsLatencyActive) {
            updateLatencyFromStatsEnvelope(body);
            updateLatencyFromStatsEnvelope(body.data || {}); // harmless if absent
          }
          return true;
        }

        if (ev === 'llm.chunk') {
          if (statsLatencyActive) {
            updateLatencyFromStatsEnvelope(body);
            updateLatencyFromStatsEnvelope(body.data || {});
          }
          handleChunk(body.id, body.seq, body.data);
          return true;
        }
        if (ev === 'llm.done') {
          sendAck(body.id, body.last_seq);
          endStream(body.id);

          statsLatencyActive = false;   // ← NEW: stop stats mode so pings resume

          // Optional: one last latency update from the done envelope if it carries a server ts
          if (useStatsLatency) {
            updateLatencyFromStatsEnvelope(body);
            updateLatencyFromStatsEnvelope(body.data || {});
          }

          // fold in any stats that arrived on the final envelope
          applyStreamStats(body.id, body);

          // guarantee a non-zero final TPS if we have tokens & timing
          const rec = statsByStream.get(body.id);
          if (rec && (!Number.isFinite(rec.tps) || rec.tps <= 0)) {
            const elapsed = Math.max(0.25, (Date.now() - (rec.startAt || Date.now())) / 1000);
            if (Number.isFinite(rec.tokens) && rec.tokens > 0) {
              rec.tps = rec.tokens / elapsed;
              rec.approx = true;
              statsByStream.set(body.id, rec);
            }
          }

          // persist TPS onto the last assistant message
          const sess = getSession();
          if (sess) {
            for (let i = sess.messages.length - 1; i >= 0; i--) {
              if (sess.messages[i].role === 'assistant') {
                const st = statsByStream.get(body.id);
                if (st && Number.isFinite(st.tps)) {
                  sess.messages[i]._tps = st.tps;
                  sess.messages[i]._tpsIsApprox = !!st.approx;
                }
                break;
              }
            }
            saveJSON(STORAGE.SESS, sessions);
          }

          finishStreamingBubble(body.id);
          renderChat();
          setSendMode();
          clearRoute(body.id);
          return true;
        }


        if (ev === 'llm.result') {
          // callback sink (e.g., model.show)
          if (route && route.sink === 'callback' && typeof route.cb === 'function') {
            try { route.cb({ ok: true, body }); } catch { }
            clearRoute(body.id);
            return true;
          }

          if (route.sink === 'element') {
            const elx = resolveEl(route.elId);
            const text = extractFull(body.data) || '';
            writeToElement(elx, text, { mode: route.mode || 'replace', format: route.format || 'text' });
            lockElement(elx, false);
            if (route.elId) streamingElements.delete(route.elId);

            if (route.elId === 'systemMsg') {
              const s = getSession();
              if (s) { s.system = (el('systemMsg').value || ''); saveJSON(STORAGE.SESS, sessions); sendSessionOpen(s, /*seed*/false); }
              setSysGenBusy(false);
              sysgenPending.delete(body.id);
            }
            isSysGenStreaming = false; sysgenCurrentId = null;
            clearRoute(body.id);
            return true;
          }

          // Non-element (chat) result — keep your capability toggle for show payloads
          try {
            if (isLikelyModelShowPayload(body.data)) {
              const raw = (body.data && body.data.data) ? body.data.data : body.data;
              const model = getCurrentModel() || '';
              const info = normalizeModelShow(model, raw);
              cacheSetModelInfo(model, info);
              renderModelInfo(info);
              const hasVision = Array.isArray(info.capabilities) && info.capabilities.some(c => String(c).toLowerCase() === 'vision');
              toggleImageAttach(hasVision);
            }
          } catch (e) { console.debug('[caps-toggle] skipped:', e); }

          const sess = getSession(); if (!sess) { clearRoute(body.id); return true; }
          renderChat();
          clearRoute(body.id);
          return true;
        }

        if (ev === 'llm.error') {
          // callback sink
          if (route.sink === 'callback' && typeof route.cb === 'function') {
            try { route.cb({ ok: false, body }); } catch { }
            clearRoute(body.id);
            return true;
          }
          if (body.kind === 'models' || (body.id && String(body.id).startsWith('models'))) {
            modelsInFlight = false; modelsLoaded = false;
            if (modelsRetryTimer) clearTimeout(modelsRetryTimer);
            showModelsError('— no models (hub error) —');
            return true;
          }
          if (route.sink === 'element') {
            const elx = resolveEl(route.elId);
            lockElement(elx, false);
            if (route.elId) streamingElements.delete(route.elId);
            setSysGenBusy(false);
            isSysGenStreaming = false; sysgenCurrentId = null;
            sysgenPending.delete(body.id);
            clearRoute(body.id);
            alert('[LLM Error] ' + (body.message || 'Error'));
            return true;
          }
          const sess = getSession(); if (!sess) return true;
          appendMessage(sess.id, 'assistant', '[error] ' + body.message);
          renderChat();
          setSendMode();
          clearRoute(body.id);
          return true;
        }

        return false; // not handled here
      }

      /* ----- Unified entrypoint (keeps your decode + logging) ----- */
      function onInbound(a, b) {
        try {
          let src, raw;
          if (a && typeof a === 'object' && (a.payload !== undefined || a.data !== undefined || a.src !== undefined)) {
            src = a.src || a.from || '';
            raw = a.payload ?? a.data;
          } else {
            src = a; raw = b;
          }

          const body = decodePayload(raw);
          if (!body || typeof body !== 'object') return;

          const ev = body.event || '';
          const srcStr = String(src || '');

          try { logRecvPacket(srcStr, raw, body); } catch { }

          if (!_sameHubOrTrusted(ev, srcStr)) return;

          // Route to CTRL first; if not handled there, DATA handler gets a chance
          if (onInboundCtrl(ev, body, srcStr)) return;
          if (onInboundData(ev, body, srcStr)) return;

          // fallthrough: ignore unknown/noisy frames silently
        } catch (err) {
          console.warn('[onInbound] swallowed error', err);
        }
      }

      /* ========= /Inbound demux ========= */




      function extractDelta(part) {
        if (part?.message?.content) return part.message.content;
        if (typeof part?.response === 'string') return part.response;
        return '';
      }
      function extractFull(obj) {
        if (obj?.message?.content) return obj.message.content;
        if (typeof obj?.response === 'string') return obj.response;
        try { return JSON.stringify(obj); } catch { return String(obj); }
      }

      // Heuristic: does this look like an `ollama.show()` payload?
      function isLikelyModelShowPayload(d) {
        if (!d || typeof d !== 'object') return false;
        // server may wrap as { data: {...} } or send raw {...}
        const obj = d.data && typeof d.data === 'object' ? d.data : d;
        return !!(obj.capabilities || obj.modelfile || obj.details || obj.modelinfo);
      }

      // Pull ONLY the `capabilities` key as a string list
      function extractCapabilitiesOnly(d) {
        const obj = d && typeof d === 'object' && d.data && typeof d.data === 'object' ? d.data : d;
        return Array.isArray(obj?.capabilities) ? obj.capabilities.map(String) : [];
      }

      function formatCapabilitiesLine(d) {
        const caps = extractCapabilitiesOnly(d);
        return 'Capabilities: ' + (caps.length ? caps.join(', ') : '—');
      }

      function setSendUploading(on) {
        const btn = el('sendBtn'); if (!btn) return;
        btn.disabled = !!on;
        btn.innerHTML = on ? loadingLoop : playSign;  // reuse your existing icons
      }

      async function uploadStagedSerial(ids) {
        for (const id of ids) {
          const up = uploads.get(id);
          if (!up || up.done) continue;
          beginUpload(id);                        // start this one
          try { await up.readyPromise; } catch { } // wait until blob.ready
        }
      }

      async function sendPrompt() {
        if (isStreaming && currentStreamId) {
          // optional: flash the stop button or show a toast here
          return;
        }

        const s = getSession(); if (!s) { alert('Choose a model first.'); return; }
        const text = el('prompt').value;
        if (!text.trim() && pendingImages.length === 0) return;

        const inlineURLs = pendingImages.filter(p => !p.big).map(p => p.dataURL);

        // Which big files still need to be uploaded?
        const stagedIds = pendingImages
          .filter(p => p.big && p.blobId)
          .map(p => p.blobId)
          .filter(id => {
            const up = uploads.get(id);
            return up && !up.done;
          });

        // If we have staged big files, upload them now (sequentially)
        if (stagedIds.length) {
          setSendUploading(true);
          try {
            await uploadStagedSerial(stagedIds);
          } finally {
            setSendUploading(false);
          }
        }

        // Collect refs (they’re set on blob.ready)
        const blobRefs = pendingImages
          .filter(p => p.big && p.blobId)
          .map(p => uploads.get(p.blobId)?.readyRef)
          .filter(Boolean);

        // Build & send the chat payload
        const doStream = !!settings.stream;
        const payload = {
          event: 'llm.request',
          id: newId('req'),
          api: 'chat',
          sid: s.id,
          delta: text.trim(),
          stream: doStream,
          kwargs: { options: currentOptions() },
          images: inlineURLs.length ? inlineURLs : undefined,
          images_ref: blobRefs.length ? blobRefs : undefined
        };

        // Sanity check: keep well under ~800 KiB per message
        const WS_MSG_BUDGET = 800 * 1024;
        if (approxBytes(payload) > WS_MSG_BUDGET) {
          alert('Message too large. Reduce inline images or size.');
          return;
        }

        // Append to UI, queue/send to hub
        appendMessage(s.id, 'user', text.trim());
        const last = s.messages[s.messages.length - 1];
        // store only tiny inline images; skip large previews to keep storage lean
        last.images = pendingImages.filter(p => !p.big).map(p => p.dataURL);
        saveJSON(STORAGE.SESS, sessions);
        renderChat();
        el('prompt').value = '';

        console.info('[CHAT.SEND]', {
          bytes: approxBytes(payload),
          hasInlineImages: !!(payload.images && payload.images.length),
          imagesInlineCount: payload.images?.length || 0,
          imagesRefCount: payload.images_ref?.length || 0,
          stream: payload.stream
        });

        requestLLM(payload, { sink: 'chat' });

        // Clear pending
        pendingImages = [];
        renderAttachments();
        pendingBlobRefs = [];
      }


      const playSign = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M16.6582 9.28638C18.098 10.1862 18.8178 10.6361 19.0647 11.2122C19.2803 11.7152 19.2803 12.2847 19.0647 12.7878C18.8178 13.3638 18.098 13.8137 16.6582 14.7136L9.896 18.94C8.29805 19.9387 7.49907 20.4381 6.83973 20.385C6.26501 20.3388 5.73818 20.0469 5.3944 19.584C5 19.053 5 18.1108 5 16.2264V7.77357C5 5.88919 5 4.94701 5.3944 4.41598C5.73818 3.9531 6.26501 3.66111 6.83973 3.6149C7.49907 3.5619 8.29805 4.06126 9.896 5.05998L16.6582 9.28638Z" stroke="#ffffff" stroke-width="2" stroke-linejoin="round"/>
</svg>`;
      const stopSign = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="4" y="4" width="16" height="16" rx="2" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;

      // Stop button behavior
      function setStopMode(id) {
        const btn = el('sendBtn');
        currentStreamId = id;
        isStreaming = true;
        StickyScroll.setGenerating(true);   // ← NEW
        btn.innerHTML = stopSign;
        btn.onclick = stopGeneration;
      }

      function setSendMode() {
        const btn = el('sendBtn');
        isStreaming = false;
        pendingStreamId = null;
        currentStreamId = null;
        StickyScroll.setGenerating(false);  // ← NEW
        btn.innerHTML = playSign;
        btn.onclick = sendPrompt;
      }

      function stopGeneration() {
        if (!currentStreamId || !HUB_ADDR) { setSendMode(); return; }
        cancelledStreams.add(currentStreamId);
        trySend(HUB_ADDR, { event: 'llm.cancel', id: currentStreamId }, { noReply: true, msgHoldingSeconds: 120 });
        setSendMode();
      }


      // System editor → persist locally and push to hub (suppressed while streaming to this element)
      el('systemMsg').addEventListener('input', debounce(() => {
        if (streamingElements.has('systemMsg')) return; // suppress while generator streams
        const s = getSession(); if (!s) return;
        s.system = el('systemMsg').value;
        saveJSON(STORAGE.SESS, sessions);
        sendSessionOpen(s, /*seed*/false);
      }, 250));

      // Settings modal
      function openSettings() { updateSettingsUI(); el('overlay').style.display = 'flex'; }
      function closeSettings() { el('overlay').style.display = 'none'; }

      // Sidebar Toggle Mobile
      function toggleSidebar() {
        const elx = document.getElementById('sidebar');
        const elxb = document.getElementById('backdrop');
        if (!elx) return;
        const curLeft = getComputedStyle(elx).left.trim();
        elx.style.left = (curLeft === '0px' || curLeft === '0%') ? '-50%' : '0%';
        elxb.style.left = (curLeft === '0px' || curLeft === '0%') ? '-100%' : '0%';
      }
      el('backdrop').onclick = toggleSidebar;
      el('toggleSidebar').onclick = toggleSidebar;

      // Boot
      function boot() {
        setConn(); // clears blue & hides label

        // Move the model select next to status + keep it hidden until we truly have models
        (() => {
          const row = el('statusRow'), sel = el('modelSelect');
          if (row && sel && sel.parentElement !== row) row.appendChild(sel);
          showModelDropdown(false); // hide until models list arrives
        })();

        // System Message toggle + actions
        el('systemToggleBtn').onclick = () => toggleSystemEditor();
        el('systemToggleBtnInside').onclick = () => toggleSystemEditor();

        // System Prompt Generate (streams back into the textarea)
        el('sysGenBtn').onclick = () => {
          const s = getSession(); if (!s) { alert('Create/select a session first.'); return; }
          if (!HUB_ADDR) { openSettings(); return; }
          if (!modelsLoaded) { alert('Models are not loaded yet. Please wait.'); return; }

          const ta = el('systemMsg');
          const userDesc = (ta.value || '').trim();
          if (!userDesc) { alert('Type what you want your system prompt to do, then click Generate.'); return; }

          const model = getCurrentModel();
          if (!model || el('modelSelect').disabled) { alert('Choose a model first, then try Generate again.'); return; }

          const genId = newId('sysgen');

          // messages-mode payload — note: NO sid here
          const payload = {
            event: 'llm.request',
            id: genId,
            api: 'chat',
            model,
            stream: true,
            messages: [
              { role: 'system', content: SYSTEM_GEN_PROMPT },
              { role: 'user', content: userDesc }
            ],
            kwargs: { options: currentOptions() },
            aux: 'sysgen'
          };

          // route the stream into the textarea
          const route = {
            sink: 'element',
            elId: 'systemMsg',
            mode: 'replace',  // first token replaces; subsequent chunks append
            format: 'text',
            lock: true
          };

          // UI state
          sysgenPending.add(genId);
          setSysGenBusy(true);
          streamingElements.add('systemMsg');
          lockElement(ta, true);

          // Send (queue-aware)
          requestLLM(payload, route);
        };

        el('sysSaveBtn').onclick = () => {
          const s = getSession();
          if (!s) { alert('Create/select a session first.'); return; }
          s.system = el('systemMsg').value || '';
          saveJSON(STORAGE.SESS, sessions);
          sendSessionOpen(s, /*seed*/false);
        };


        // --- System metadata toggles wiring ---
        updateSysMetaButtons();
        applySystemMeta(false); // ensure editor reflects current toggle prefs without sending yet

        el('sysLocBtn').onclick = async () => {
          sysMetaPrefs.loc = !sysMetaPrefs.loc; saveSysMetaPrefs(); updateSysMetaButtons();
          if (sysMetaPrefs.loc) {
            try { await ensureLoc(); }
            catch (e) {
              sysMetaPrefs.loc = false; saveSysMetaPrefs(); updateSysMetaButtons();
              alert('Location permission denied or unavailable.');
            }
          }
          applySystemMeta(true);
        };

        el('sysTimeBtn').onclick = () => {
          sysMetaPrefs.time = !sysMetaPrefs.time; saveSysMetaPrefs(); updateSysMetaButtons();
          if (sysMetaPrefs.time) captureTime();
          applySystemMeta(true);
        };

        el('sysUaBtn').onclick = () => {
          sysMetaPrefs.ua = !sysMetaPrefs.ua; saveSysMetaPrefs(); updateSysMetaButtons();
          if (sysMetaPrefs.ua) captureUa();
          applySystemMeta(true);
        };


        // Attach button opens file picker
        el('attachBtn').onclick = () => { const fi = el('fileInput'); if (fi) fi.click(); };

        // When files chosen, read as data URLs into pendingImages[]
        el('fileInput').addEventListener('change', async (ev) => {
          const input = ev.target;
          if (input._busy) return;
          input._busy = true;

          try {
            const files = Array.from(input.files || []);
            for (const f of files) {
              if (!/^image\//i.test(f.type)) continue;

              const fp = [f.name || '', f.size || 0, f.lastModified || 0].join(':');
              const already = pendingImages.some(p => p.fp === fp);
              if (already) continue;

              if (f.size > PACK_INLINE_MAX) {
                // small preview (first ~200 KiB slice)
                const previewURL = await new Promise((res, rej) => {
                  const fr = new FileReader();
                  fr.onload = () => res(String(fr.result || ''));
                  fr.onerror = rej; fr.readAsDataURL(f.slice(0, 200 * 1024));
                });

                const blobId = await stageBlob(f); // ← stage only, no network
                pendingImages.push({
                  name: f.name,
                  size: f.size,
                  type: f.type,
                  dataURL: previewURL,
                  big: true,
                  blobId,
                  pct: 0,
                  staged: true,   // ← NEW: used by UI to show "staged"
                  fp
                });
                renderAttachments();
              } else {
                // unchanged (inline)
                const dataURL = await new Promise((res, rej) => {
                  const fr = new FileReader();
                  fr.onload = () => res(String(fr.result || ''));
                  fr.onerror = rej; fr.readAsDataURL(f);
                });
                pendingImages.push({ name: f.name, size: f.size, type: f.type, dataURL, big: false, pct: 100, fp });
                renderAttachments();
              }
            }
          } finally {
            input.value = '';
            setTimeout(() => { input._busy = false; }, 0);
          }
        });


        // Apply hub from URL before anything else that depends on it
        applyHubFromUrl();

        renderSessions(); renderSystemEditor(); renderChat(); updateSettingsUI();

        // Ensure HUB_ADDR reflects (possibly updated) settings.hub
        HUB_ADDR = settings.hub || '';
        HUB_KEY = (HUB_ADDR.split('.')[1] || '').toLowerCase();  // <— NEW
        updateChips();

        // Wire inputs
        el('sendBtn').onclick = sendPrompt;
        el('prompt').addEventListener('keydown', e => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (isStreaming && currentStreamId) {
              // cancel instead of sending while a stream is active
              stopGeneration();
            } else {
              sendPrompt();
            }
          }
        });

        el('settingsBtn').onclick = openSettings;
        el('closeModal').onclick = closeSettings;
        el('backdropModal').onclick = closeSettings;
        el('saveSettings').onclick = () => { if (saveSettingsFromUI()) { closeSettings(); } };

        // NEW: reset local NKN key and reconnect (no full reload needed)
        (() => {
          const btn = el('resetKeyBtn');
          if (!btn) return;
          btn.onclick = () => {
            if (!confirm('Reset your local NKN key? A new keypair will be generated and the client will reconnect.')) return;
            localStorage.removeItem(STORAGE.SEED);
            try { client && client.close && client.close(); } catch { }
            client = null;
            myAddr = null;
            updateChips();
            setConn(RECONNECTING_HTML);
            connectNKN();
          };
        })();


        // Disallow creating a session until models have actually loaded
        const newBtn = el('newSessionBtn');
        if (newBtn) {
          newBtn.disabled = true; // start disabled
          newBtn.onclick = () => {
            const sel = el('modelSelect');
            const model = sel && sel.value;
            if (!modelsLoaded || !model || sel.disabled || /loading|no models/i.test(String(sel.options[0]?.text || ''))) {
              alert('Models are not ready yet. Please wait for the list to load.');
              return;
            }
            createSessionForModel(model);
          };
        }

        // Also protect the model select itself until ready
        const modelSel = el('modelSelect');
        if (modelSel) {
          modelSel.disabled = true;     // will be enabled when populateModels() runs
          modelSel.classList.add('hide');
        }

        // Keep existing session selection behavior
        if (activeSessionId) setActiveSession(activeSessionId);

        // Kick off NKN connect; onConnect()
        connectNKN();
      }
      // Boot exactly once
      if (!window[SINGLETON_KEY].booted) {
        boot();
        window[SINGLETON_KEY].booted = true;
      }
      window[SINGLETON_KEY].api = Object.freeze({
        connectNKN,
        sendPrompt,
        stopGeneration,
        getSession,
        setActiveSession
      });
    })();
  </script>


</body>

</html>