<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>NKN Client — LLM Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <meta name="theme-color" content="#000" />
  <!-- NKN SDK -->
  <script src="https://unpkg.com/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
  <script>
    /* 1) Harden RTCPeerConnection.setRemoteDescription against closed-state races */
    (() => {
      const RTCPeer =
        window.RTCPeerConnection ||
        window.webkitRTCPeerConnection ||
        window.mozRTCPeerConnection;

      if (!RTCPeer || RTCPeer.prototype.__patchedRemoteDesc) return;

      const origSRD = RTCPeer.prototype.setRemoteDescription;

      RTCPeer.prototype.setRemoteDescription = function (...args) {
        if (this.signalingState === 'closed') {
          // Swallow “InvalidStateError: signalingState is 'closed'”
          return Promise.resolve();
        }
        try {
          const p = origSRD.apply(this, args);
          return Promise.resolve(p).catch((err) => {
            const name = err && err.name;
            const msg = (err && (err.message || String(err))) || '';
            if (name === 'InvalidStateError' || /signalingState.*closed/i.test(msg)) {
              // Treat as benign; connection already torn down
              return;
            }
            throw err;
          });
        } catch (err) {
          const name = err && err.name;
          const msg = (err && (err.message || String(err))) || '';
          if (name === 'InvalidStateError' || /signalingState.*closed/i.test(msg)) {
            return Promise.resolve();
          }
          throw err;
        }
      };

      RTCPeer.prototype.__patchedRemoteDesc = true;
    })();
  </script>

  <script>
    /* 2) Mute noisy transient/unrecoverable rejections from the NKN stack */
    window.addEventListener('unhandledrejection', (e) => {
      const r = e && e.reason;
      const name = r && r.name;
      const msg = String((r && (r.message || r)) || e);

      // Already had some filters — extend them to cover WebRTC/WebSocket flaps
      const shouldSuppress =
        name === 'InvalidStateError' ||
        /setRemoteDescription/i.test(msg) ||
        /RTC(DataChannel|PeerConnection)/i.test(msg) ||
        /WebSocket unexpectedly closed/i.test(msg) ||
        /Message timeout/i.test(msg) ||
        /ConnectToNodeTimeoutError/i.test(msg);

      if (shouldSuppress) {
        e.preventDefault();
      }
    });
  </script>

  <!-- Import map (kept as requested) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
    }
  }
  </script>

  <!-- QR, Markdown, and Syntax Highlighting -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs-themes@1.0.0/tomorrow-night-blue.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Instrument+Sans:ital,wght@0,400..700;1,400..700&display=swap');

    :root {
      --bg: #000;
      --panel: #0a0a0a;
      --line: #141414;
      --fg: #fff;
      --muted: #bfbfbf;
      --accent: #fff;
      --pad: 12px;
      --radius: 14px;
      --shadow: 0 12px 30px rgba(0, 0, 0, .45);
    }

    * {
      box-sizing: border-box;
      transition: all 0.2s ease;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: "Instrument Sans", sans-serif;
      touch-action: manipulation;
      user-select: none;
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 260px 1fr;
      grid-template-areas: "top top" "left main";
      height: 100%
    }

    input:focus,
    textarea:focus {
      outline: none;
    }

    header {
      max-height: 400px;
      grid-area: top;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-flow: wrap;
      gap: 10px;
      padding: 10px var(--pad);
      background: #000;
      position: sticky;
      top: 0;
      z-index: 20;
      border-bottom: 1px solid var(--line)
    }

    .brand {
      font-weight: 700;
      letter-spacing: .3px
    }

    .spacer {
      flex: 1
    }

    .topbar-select {
      appearance: none;
      background: #000;
      border: 1px solid #2a2a2a;
      color: var(--fg);
      padding: 8px 10px;
      border-radius: 8px;
      line-height: 1;
      height: 38px;
      max-width: calc(100vw - 154px);
    }

    .chip {
      padding: 6px 10px;
      border: 1px solid #2a2a2a;
      border-radius: 999px;
      color: #eaeaea;
      background: #0a0a0a;
      display: flex;
      gap: 0.5rem;
    }

    .chip b {
      margin: auto;
    }

    .chiprow {
      display: flex;
      flex-flow: row;
      gap: 1rem;
      margin-bottom: 1rem;
      line-height: 1;

    }

    .gear {
      display: flex;
      flex-flow: row;
      justify-content: center;
      min-width: 34px;
      min-height: 34px;
      cursor: pointer;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 10px 10px;
      font-size: 14px;
      line-height: 1;
      background: #0a0a0a;
      color: white;
    }

    .gear:active {
      transform: scale(1.02)
    }

    .col-left {
      grid-area: left;
      border-right: 1px solid #141414;
      background: #050505;
      display: flex;
      flex-direction: column;
      min-width: 0
    }

    .left-head {
      padding: 10px var(--pad);
      border-bottom: 1px solid #141414;
      display: flex;
      align-items: center;
      gap: 8px
    }

    .sessions {
      flex: 1;
      overflow: auto;
      padding: 8px
    }

    .session {
      position: relative;
      padding: 10px;
      border: 1px solid #1a1a1a;
      border-radius: 12px;
      margin-bottom: 8px;
      background: #0a0a0a;
      cursor: pointer
    }

    .session.active {
      border-color: #fff
    }

    .session .title {
      font-weight: 600;
      padding-right: 28px
    }

    .session small {
      color: #cfcfcf;
      opacity: .8
    }

    .session .del {
      position: absolute;
      top: 0px;
      right: 0px;
      height: 32px;
      width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      cursor: pointer;
      border: unset;
      background: transparent;
    }

    .session .del:hover {}

    .col-main {
      position: relative;
      box-sizing: border-box;
      grid-area: main;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      min-width: 0
    }

    .sysedit {
      padding: 12px;
      border-bottom: 1px solid #141414;
      background: #050505;
      box-sizing: border-box;
      height: auto;
      width: 100%;
      line-height: 1;
      box-shadow: 0px 0px 20px 10px black;
      z-index: 2;
      position: absolute;
      top: 0px;

    }

    .sysedit label {
      display: block;
      font-size: 12px;
      color: #cfcfcf;
      margin-bottom: 6px;
    }

    .sysinput {
      width: 100%;
      min-height: 64px;
      resize: vertical;
      background: #000;
      border: 1px solid #2a2a2a;
      color: #fff5;
      border-radius: 12px;
      padding: 10px
    }

    .sysinput:focus {
      outline: none;
      border-color: #fff;
      color: #fff
    }

    .chat {
      position: relative;
      display: block;
      height: 100%;
      flex: 1;
      overflow: auto;
      padding: 16px;
      max-height: calc(100vh - 180px);
      scroll-behavior: smooth
    }

    .msg {
      max-width: 900px;
      margin: 0 auto 14px auto;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid #1a1a1a
    }

    .user {
      background: #0a0a0a
    }

    .assistant {
      background: #0a0a0a;
      border-color: #2a2a2a
    }

    .meta {
      display: flex;
      gap: 10px;
      align-items: center;
      color: #bfbfbf;
      font-size: 12px;
      margin-bottom: 6px
    }

    .content {
      word-wrap: break-word
    }

    .content p {
      margin: .5em 0
    }

    .content img {
      max-width: 100%;
      border-radius: 8px
    }

    .content code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      background: #0b0b0b;
      border: 1px solid #2a2a2a;
      border-radius: 6px;
      padding: .2em .35em
    }

    .content pre {
      background: #0b0b0b;
      border: 1px solid #2a2a2a;
      border-radius: 12px;
      padding: 12px;
      overflow: auto
    }

    .content pre code {
      background: transparent;
      border: none;
      padding: 0
    }

    .content blockquote {
      border-left: 3px solid #2a2a2a;
      margin: 8px 0;
      padding: 6px 10px;
      color: #cfd8dc;
      background: #071018;
      border-radius: 8px
    }

    .content ul,
    .content ol {
      padding-left: 1.4em
    }

    .composer {
      display: flex;
      gap: 10px;
      padding: 12px;
      border-top: 1px solid #141414;
      background: #050505
    }

    .input {
      flex: 1;
      resize: none;
      height: 40px;
      border: unset;
      background: #000;
      color: var(--fg);
      border-radius: 12px;
      padding: 12px
    }


    #systemToggleBtn {
      color: #2a2a2a;
      border-color: #2a2a2a;
    }

    .btnSq {
      aspect-ratio: 1 / 1;
    }

    .btn {
      background-color: black;
      border: 1px solid #fff;
      color: #fff;
      padding: 8px 8px;
      line-height: 1;
      display: flex;
      flex-flow: column;
      justify-content: center;
      border-radius: 8px;
      cursor: pointer
    }

    .btn:hover {
      background-color: white;
      border: 1px solid #fff;
      color: #000;
      padding: 8px 8px;
      line-height: 1;
      display: flex;
      flex-flow: column;
      justify-content: center;
      cursor: pointer
    }

    .btn:hover>svg path {
      stroke: black;
    }

    .btn:active {
      transform: translateY(1px)
    }

    @keyframes dotdotdot {
      0% {
        content: '.'
      }

      33% {
        content: '..'
      }

      66% {
        content: '...'
      }

      100% {
        content: ''
      }

    }

    .dot {
      animation: dotdotdot 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg)
      }

      100% {
        transform: rotate(360deg)
      }

    }

    @keyframes bump {
      0% {
        transform: translateX(0px)
      }

      40% {
        transform: translateX(-3px)rotate(-5deg)
      }

      60% {
        transform: translateX(3px)rotate(5deg)
      }

      100% {
        transform: translateX(0px)rotate(0deg)
      }

    }

    .sendButton {
      background: transparent;
      border: unset;
      cursor: pointer;
    }

    .sendButton:hover {
      animation: bump 0.3s ease-in-out;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .muted {
      color: #cfcfcf;
      opacity: .8
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      backdrop-filter: blur(10px);
    }

    .modal {
      width: min(560px, 92vw);
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 14px
    }

    .modal h3 {
      margin: .2rem 0 .8rem 0
    }

    .modal>.row {
      display: flex;
      justify-content: flex-start;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px
    }

    .text {
      background: #000;
      border: 1px solid #2a2a2a;
      color: #fff;
      padding: 10px;
      border-radius: 8px
    }

    .num {
      background: #000;
      border: 1px solid #2a2a2a;
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      width: 120px
    }

    .chkrow {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 6px
    }

    .modal .row {
      justify-content: flex-end;
      margin-top: 10px
    }

    /* ── Connection status dot in header ───────────────────────────────────── */
    .conn-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid #2a2a2a;
      display: none;
    }

    .conn-blue {
      background: #3b82f6;
    }

    /* connecting / reconnecting */
    .conn-green {
      background: #22c55e;
    }

    /* connected */
    .conn-red {
      background: #ef4444;
    }

    /* error / disconnected */

    .hide {
      display: none !important;
    }

    /* helper to hide model select until ready */
    #toggleSidebar {
      display: none;
    }

    .backdropModal {
      height: 100vh;
      width: 100vw;
      position: fixed;
      top: 0px;
      left: 0px;
      z-index: -1;
    }

    @media (max-width: 900px) {
      #toggleSidebar {
        display: flex;
      }

      .app {
        grid-template-columns: 1fr;
        grid-template-areas: "top" "main"
      }

      .col-left {
        display: flex;
        position: absolute;
        width: 50%;
        z-index: 10;
        left: -50%;
        top: 54px;
        bottom: 0px;
      }

      #backdrop {
        height: 100vh;
        position: absolute;
        bottom: 0px;
        width: 100vw;
        left: -100%;
        backdrop-filter: blur(10px);
        z-index: -1;
      }
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <button class="gear" id="toggleSidebar" onclick="toggleSidebar()">
        <!-- (icon unchanged) -->
        <svg width="16px" height="16px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M11 5V19M6 8H8M6 11H8M6 14H8M6.2 19H17.8C18.9201 19 19.4802 19 19.908 18.782C20.2843 18.5903 20.5903 18.2843 20.782 17.908C21 17.4802 21 16.9201 21 15.8V8.2C21 7.0799 21 6.51984 20.782 6.09202C20.5903 5.71569 20.2843 5.40973 19.908 5.21799C19.4802 5 18.9201 5 17.8 5H6.2C5.0799 5 4.51984 5 4.09202 5.21799C3.71569 5.40973 3.40973 5.71569 3.21799 6.09202C3 6.51984 3 7.07989 3 8.2V15.8C3 16.9201 3 17.4802 3.21799 17.908C3.40973 18.2843 3.71569 18.5903 4.09202 18.782C4.51984 19 5.07989 19 6.2 19Z"
            stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
      </button>

      <!-- NEW: connection status (dot + label). The model select will be injected next to this. -->
      <div id="statusRow" class="row">
        <span id="connDot" class="conn-dot" aria-hidden="true"></span>
        <span id="connText" class="muted"></span>
      </div>

      <!-- The select stays in DOM; we will move it next to #statusRow and hide it until models are ready -->
      <select id="modelSelect" class="topbar-select" title="Available models" disabled>
        <option style="text-align:center;">Loading Models</option>
      </select>

      <button id="settingsBtn" class="gear btnSq" aria-label="Settings">
        <!-- (icon unchanged) -->
        <svg width="16px" height="16px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M12 3L14.0357 8.16153C14.2236 8.63799 14.3175 8.87622 14.4614 9.0771C14.5889 9.25516 14.7448 9.41106 14.9229 9.53859C15.1238 9.68245 15.362 9.77641 15.8385 9.96432L21 12L15.8385 14.0357C15.362 14.2236 15.1238 14.3175 14.9229 14.4614C14.7448 14.5889 14.5889 14.7448 14.4614 14.9229C14.3175 15.1238 14.2236 15.362 14.0357 15.8385L12 21L9.96432 15.8385C9.77641 15.362 9.68245 15.1238 9.53859 14.9229C9.41106 14.7448 9.25516 14.5889 9.0771 14.4614C8.87622 14.3175 8.63799 14.2236 8.16153 14.0357L3 12L8.16153 9.96432C8.63799 9.77641 8.87622 9.68245 9.0771 9.53859C9.25516 9.41106 9.41106 9.25516 9.53859 9.0771C9.68245 8.87622 9.77641 8.63799 9.96432 8.16153L12 3Z"
            stroke="#ffffff" stroke-width="2" stroke-linejoin="round" />
        </svg>
      </button>
    </header>

    <aside id="sidebar" class="col-left">
      <div class="left-head row">
        <div style="font-weight:600">Sessions</div>
        <div class="spacer"></div>
        <button id="newSessionBtn" class="btn btnSq"><svg width="16px" height="16px" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg">
            <path d="M6 12H18M12 6V18" stroke="#ffffff" stroke-width="2" stroke-linecap="round"
              stroke-linejoin="round" />
          </svg></button>
      </div>
      <div id="sessions" class="sessions"></div>
      <div id="backdrop" class="backdrop" onclick="toggleSidebar()"></div>
    </aside>

    <main class="col-main">
      <div class="sysedit">
        <!-- Collapsed default: a button (you'll style it) -->
        <button id="systemToggleBtn" class="btn">System Message</button>

        <!-- Revealed editor -->
        <div id="systemEditorWrap" class="hide">
          <textarea id="systemMsg" class="sysinput"
            placeholder="(Optional) e.g. 'You are a concise assistant. Answer with short bullets.'"></textarea>

          <div class="row" id="systemActions" style="margin-top:8px">

            <button id="sysGenBtn" class="btn" type="button">Generate</button>
            <button id="sysSaveBtn" class="btn" type="button">Save</button>
            <button id="systemToggleBtnInside" class="btn">Close</button>

          </div>
        </div>

      </div>

      <div id="chat" class="chat"></div>

      <div class="composer">
        <textarea id="prompt" class="input" placeholder="Type a message… (Shift+Enter = newline)"></textarea>
        <button id="sendBtn" class="sendButton"><svg width="16px" height="16px" viewBox="0 0 24 24" fill="none"
            xmlns="http://www.w3.org/2000/svg">
            <path
              d="M16.6582 9.28638C18.098 10.1862 18.8178 10.6361 19.0647 11.2122C19.2803 11.7152 19.2803 12.2847 19.0647 12.7878C18.8178 13.3638 18.098 13.8137 16.6582 14.7136L9.896 18.94C8.29805 19.9387 7.49907 20.4381 6.83973 20.385C6.26501 20.3388 5.73818 20.0469 5.3944 19.584C5 19.053 5 18.1108 5 16.2264V7.77357C5 5.88919 5 4.94701 5.3944 4.41598C5.73818 3.9531 6.26501 3.66111 6.83973 3.6149C7.49907 3.5619 8.29805 4.06126 9.896 5.05998L16.6582 9.28638Z"
              stroke="#ffffff" stroke-width="2" stroke-linejoin="round" />
          </svg></button>
      </div>
    </main>
  </div>

  <!-- Settings Modal -->
  <div id="overlay" class="overlay">
    <div class="modal">
      <h3>Settings</h3>
      <div class="field">
        <label>Hub address (signaling server) <span class="muted">(identifier.publicKeyHex64)</span></label>
        <input id="hubInput" class="text" placeholder="e.g. hub.0123abcd…64hex" spellcheck="false" />
      </div>

      <div class="chiprow">
        <div class="chip"><b id="hubChipIcon"></b><b id="hubChip"></b></div>
        <div id="linkIcon" style="margin: auto 0px;"></div>
        <div class="chip"><b id="meChipIcon"></b><b id="meChip"></b></div>
      </div>

      <div class="row" style="gap:20px;flex-wrap:wrap;justify-content: flex-start;">
        <div class="field"><label>Temperature</label><input id="optTemperature" class="num" type="number" step="0.01"
            min="0" max="2" /></div>
        <div class="field"><label>Top-p</label><input id="optTopP" class="num" type="number" step="0.01" min="0"
            max="1" /></div>
        <div class="field"><label>Seed</label><input id="optSeed" class="num" type="number" step="1" /></div>
        <div class="field"><label>Context (num_ctx)</label><input id="optNumCtx" class="num" type="number" step="1"
            min="128" /></div>
      </div>
      <div class="field">
        <div class="chkrow">
          <input id="optStream" type="checkbox" />
          <label for="optStream">Stream responses by default</label>
        </div>
        <div class="muted" style="margin-top:2px">Uncheck to request non-streaming results.</div>
      </div>
      <div class="row">
        <button id="resetKeyBtn" class="btn" style="border-color:#e84d4d;color:#e84d4d;background:#0a0a0a">Reset
          Key</button>
        <div class="spacer"></div>
        <button id="closeModal" class="btn" style="background:#0a0a0a;border-color:#2a2a2a">Close</button>
        <button id="saveSettings" class="btn">Save</button>
      </div>
      <div class="muted" style="font-size:12px;margin-top:6px">
        Resets your local NKN seed (32‑byte) and reconnects with a new keypair.
      </div>
    </div>
    <div class="backdropModal" onclick="closeSettings()"></div>
  </div>

  <!-- Copy-to-clipboard helper for code blocks -->
  <script>
    (() => {
      const style = document.createElement('style');
      style.textContent = `
    pre { position: relative; }
    .code-copy-btn {
      position: absolute; top: 8px; right: 8px;
      background: rgba(255,255,255,.06);
      border: 1px solid #2a2a2a;
      color: #eaeaea;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
    }
    .code-copy-btn:active { transform: translateY(1px); }
    .code-copy-btn.ok {
      border-color: #4caf50;
      color: #b2fab4;
    }
  `;
      document.head.appendChild(style);

      const hasSelection = () => {
        const sel = window.getSelection && window.getSelection();
        return sel && String(sel).length > 0;
      };
      const flash = (btn, msg = 'Copied!') => {
        const orig = btn.textContent;
        btn.textContent = msg;
        btn.classList.add('ok');
        setTimeout(() => {
          btn.textContent = orig;
          btn.classList.remove('ok');
        }, 1200);
      };
      const fallbackCopy = (text, btn) => {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.top = '-1000px';
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        try { flash(btn, document.execCommand('copy') ? 'Copied!' : 'Failed'); }
        catch { flash(btn, 'Failed'); }
        finally { document.body.removeChild(ta); }
      };
      const doCopy = (codeEl, btn) => {
        const text = codeEl.textContent || '';
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(
            () => flash(btn, 'Copied!'),
            () => fallbackCopy(text, btn)
          );
        } else fallbackCopy(text, btn);
      };
      const attachButton = (codeEl) => {
        if (!codeEl || codeEl.dataset.copyAttached === '1') return;
        const pre = codeEl.closest('pre'); if (!pre) return;
        if (pre.querySelector('.code-copy-btn')) { codeEl.dataset.copyAttached = '1'; return; }
        const btn = document.createElement('button');
        btn.type = 'button'; btn.className = 'code-copy-btn'; btn.textContent = 'Copy';
        pre.appendChild(btn);
        btn.addEventListener('click', (e) => { e.stopPropagation(); doCopy(codeEl, btn); });
        pre.addEventListener('click', () => { if (!hasSelection()) doCopy(codeEl, btn); });
        codeEl.dataset.copyAttached = '1';
      };
      const scan = (root = document) => { root.querySelectorAll('pre > code').forEach(attachButton); };
      const mo = new MutationObserver((muts) => {
        for (const m of muts) m.addedNodes && m.addedNodes.forEach((n) => {
          if (n.nodeType !== 1) return;
          if (n.matches && n.matches('pre > code')) attachButton(n); else scan(n);
        });
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', () => scan()); else scan();
    })();
  </script>


  <script>
    // ─────────── Utils & storage
    const $ = s => document.querySelector(s);
    const el = id => document.getElementById(id);
    const short = s => s ? (s.slice(0, 7) + '…' + s.slice(-6)) : '—';
    const isNknAddr = s => /^[A-Za-z0-9_-]+\.[0-9a-f]{64}$/.test((s || '').trim());
    const debounce = (fn, ms = 300) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; };

    // Markdown + code highlighting setup
    marked.setOptions({ gfm: true, breaks: true, headerIds: false, mangle: false });
    function mdToHtml(s) { try { return marked.parse(String(s || '')); } catch { return String(s || ''); } }
    function highlightIn(node) { try { node.querySelectorAll('pre code').forEach(block => { try { hljs.highlightElement(block); } catch { } }); } catch { } }

    const STORAGE = {
      SESS: 'CLIENT_SESSIONS_V2',
      SETTINGS: 'CLIENT_SETTINGS_V2',
      SEED: 'CLIENT_SEED_HEX_V2',
      HUB: 'CLIENT_HUB_ADDR_V2',
      LEGACY_SEED: 'PEERBALLS_SEED_HEX',
      LEGACY_HUB: 'PEERBALLS_HUB_ADDR',
      LAST_MODEL: 'CLIENT_LAST_SELECTED_MODEL_V2'
    };

    function loadJSON(key, fallback) {
      try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); } catch { return fallback; }
    }
    function saveJSON(key, val) { localStorage.setItem(key, JSON.stringify(val)); }

    const toHex = buf => Array.from(buf).map(b => b.toString(16).padStart(2, '0')).join('');
    function getOrCreateSeed() {
      let hex = localStorage.getItem(STORAGE.SEED) || localStorage.getItem(STORAGE.LEGACY_SEED);
      if (/^[0-9a-f]{64}$/.test(hex || '')) return hex;
      const r = new Uint8Array(32); crypto.getRandomValues(r); hex = toHex(r);
      localStorage.setItem(STORAGE.SEED, hex); return hex;
    }

    // Settings
    const settings = (() => {
      const defaultHub = localStorage.getItem(STORAGE.HUB) || localStorage.getItem(STORAGE.LEGACY_HUB) || '';
      return loadJSON(STORAGE.SETTINGS, {
        hub: defaultHub, temperature: 0.2, top_p: 0.9, seed: 0, num_ctx: 4096, stream: true
      });
    })();

    // --- URL param → hub (supports ?hub=… or #hub=… and aliases) ---
    function getUrlHubParam() {
      const tryRead = (sp) => sp.get('hub') || sp.get('nkn') || sp.get('signaling') || sp.get('signal');
      let v = '';
      try { v = tryRead(new URLSearchParams(location.search)) || ''; } catch { }
      if (!v && location.hash && location.hash.includes('=')) {
        try { v = tryRead(new URLSearchParams(location.hash.slice(1))) || ''; } catch { }
      }
      return (v || '').trim();
    }
    function applyHubFromUrl() {
      const h = getUrlHubParam();
      if (h && isNknAddr(h)) {
        settings.hub = h;
        saveJSON(STORAGE.SETTINGS, settings);
        localStorage.setItem(STORAGE.HUB, h);
        try {
          const url = new URL(location.href);
          ['hub', 'nkn', 'signaling', 'signal'].forEach(k => url.searchParams.delete(k));
          history.replaceState(null, '', url.toString());
        } catch { }
      }
    }

    function updateSettingsUI() {
      el('hubInput').value = settings.hub || '';
      el('optTemperature').value = settings.temperature;
      el('optTopP').value = settings.top_p;
      el('optSeed').value = settings.seed;
      el('optNumCtx').value = settings.num_ctx;
      el('optStream').checked = !!settings.stream;
    }
    function saveSettingsFromUI() {
      const prevHub = settings.hub;
      const hub = el('hubInput').value.trim();
      if (!isNknAddr(hub)) { alert('Invalid hub address'); return false; }
      settings.hub = hub;
      settings.temperature = parseFloat(el('optTemperature').value || '0') || 0;
      settings.top_p = parseFloat(el('optTopP').value || '1') || 1;
      settings.seed = parseInt(el('optSeed').value || '0', 10) || 0;
      settings.num_ctx = parseInt(el('optNumCtx').value || '4096', 10) || 4096;
      settings.stream = !!el('optStream').checked;
      saveJSON(STORAGE.SETTINGS, settings);
      localStorage.setItem(STORAGE.HUB, settings.hub);
      if (prevHub !== settings.hub) { location.reload(); return false; }
      const s = getSession(); if (s) sendSessionOpen(s, /*seed*/false);
      return true;
    }

    // Sessions
    let sessions = loadJSON(STORAGE.SESS, []);
    let activeSessionId = (sessions[0]?.id) || null;

    const getSavedModel = () => localStorage.getItem(STORAGE.LAST_MODEL) || (sessions[0]?.model || '');
    const setSavedModel = (m) => { if (m) localStorage.setItem(STORAGE.LAST_MODEL, m); };

    function getCurrentModel() {
      const s = getSession();
      const candidate =
        (s && s.model) ||
        (el('modelSelect') && el('modelSelect').value) ||
        getSavedModel() ||
        '';
      return isValidModelName(candidate) ? candidate : '';
    }

    function newId(prefix = 'id') { return prefix + '-' + Math.random().toString(16).slice(2) + Date.now().toString(36); }
    function createSessionForModel(model) {
      // HARD GUARD: do not create sessions until real models are loaded & valid
      if (!modelsLoaded || !isValidModelName(model)) {
        console.warn('[session] blocked: model list not ready or invalid model:', model);
        // Optional UX nudge:
        try { alert('Models are not ready yet. Please wait for the list to load.'); } catch { }
        return;
      }

      const id = newId('sess');
      const s = { id, title: model, model, system: '', createdAt: Date.now(), messages: [] };
      sessions.unshift(s);
      activeSessionId = id;
      saveJSON(STORAGE.SESS, sessions);
      setSavedModel(model);

      renderSessions();
      renderSystemEditor();
      renderChat();
      sendSessionOpen(s, /*seed*/true);
    }
    function getSession(id = activeSessionId) { return sessions.find(x => x.id === id) || null; }
    function setActiveSession(id) {
      activeSessionId = id;
      const s = getSession();
      if (s && s.model) {
        setSavedModel(s.model);
        const sel = el('modelSelect');
        if (sel && Array.from(sel.options).some(o => o.value === s.model)) sel.value = s.model;
      }
      renderSessions(); renderSystemEditor(); renderChat();
      if (s) sendSessionOpen(s, /*seed*/true);
    }
    function appendMessage(sessId, role, content) {
      const s = getSession(sessId); if (!s) return; s.messages.push({ role, content, ts: Date.now() }); saveJSON(STORAGE.SESS, sessions);
    }
    function updateLastAssistantContent(sessId, content) {
      const s = getSession(sessId); if (!s) return;
      for (let i = s.messages.length - 1; i >= 0; i--) {
        if (s.messages[i].role === 'assistant') { s.messages[i].content = content; break; }
      }
      saveJSON(STORAGE.SESS, sessions);
    }
    function deleteSession(id) {
      const idx = sessions.findIndex(x => x.id === id);
      if (idx === -1) return;
      const sid = sessions[idx].id;
      sendSessionReset(sid);
      sessions.splice(idx, 1);
      saveJSON(STORAGE.SESS, sessions);
      if (activeSessionId === id) activeSessionId = sessions[0]?.id || null;
      if (sessions[0]?.model) setSavedModel(sessions[0].model);
      renderSessions(); renderSystemEditor(); renderChat();
      if (activeSessionId) { const s = getSession(); if (s) sendSessionOpen(s, /*seed*/true); }
    }

    function renderSessions() {
      const box = el('sessions'); box.innerHTML = '';
      sessions.forEach(s => {
        const div = document.createElement('div'); div.className = 'session' + (s.id === activeSessionId ? ' active' : '');
        div.onclick = () => setActiveSession(s.id);
        div.innerHTML = `
        <div class="title">${s.title || s.model || 'Session'}</div>
        <small>${s.model || ''} • ${new Date(s.createdAt).toLocaleString()}</small>
        <button class="del" title="Delete session" aria-label="Delete"><svg width="16px" height="16px" viewBox="0 0 24 24" style="transform:rotate(45deg);" fill="none"
            xmlns="http://www.w3.org/2000/svg">
            <path d="M6 12H18M12 6V18" stroke="#ffffff" stroke-width="2" stroke-linecap="round"
              stroke-linejoin="round" />
          </svg></button>
      `;
        const del = div.querySelector('.del');
        del.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm('Delete this session?')) deleteSession(s.id);
        });
        box.appendChild(div);
      });
    }

    // Markdown renderer for message body
    function messageHtml(role, content) { return mdToHtml(content || ''); }

    function renderSystemEditor() {
      const s = getSession();
      const ta = el('systemMsg');
      if (!s) {
        ta.value = '';
        ta.placeholder = '(Select or create a session to set a system prompt)';
        ta.disabled = true;
        return;
      }
      ta.disabled = false;
      ta.value = s.system || '';
      ta.placeholder = "(Optional) e.g. 'You are a concise assistant. Answer with short bullets.'";
    }

    function renderChat() {
      const s = getSession(); const box = el('chat'); box.innerHTML = '';
      if (!s) { box.innerHTML = `<div class="muted" style="text-align:center;margin-top:30px">Choose a model above to create a session.</div>`; return; }
      s.messages.forEach(m => {
        const w = document.createElement('div'); w.className = 'msg ' + (m.role === 'user' ? 'user' : 'assistant');
        const contentHtml = messageHtml(m.role, m.content);
        w.innerHTML = `<div class="meta">${m.role} • ${new Date(m.ts).toLocaleTimeString()}</div><div class="content">${contentHtml}</div>`;
        box.appendChild(w);
        highlightIn(w);
      });
      box.scrollTop = box.scrollHeight;
    }

    function addStreamingAssistantBubble() {
      const s = getSession(); if (!s) return;
      const w = document.createElement('div'); w.className = 'msg assistant'; w.dataset.stream = '1';
      w.innerHTML = `<div class="meta">assistant • streaming…</div><div class="content" id="streamContent"></div>`;
      el('chat').appendChild(w); el('chat').scrollTop = el('chat').scrollHeight;
    }
    function setStreamingContent(text) {
      const c = el('streamContent');
      if (c) {
        c.innerHTML = mdToHtml(text || '');
        highlightIn(c);
        el('chat').scrollTop = el('chat').scrollHeight;
      }
    }
    function finishStreamingBubble() {
      const c = el('streamContent'); if (c) { c.removeAttribute('id'); }
      const m = document.querySelector('.msg.assistant[data-stream="1"] .meta'); if (m) m.textContent = 'assistant • done';
      const w = document.querySelector('.msg.assistant[data-stream="1"]'); if (w) w.dataset.stream = '0';
    }

    // --- System Message helpers/state ---
    const SYSTEM_GEN_PROMPT =
      "You are a system prompt generator. Given the user's description, return ONE highly detailed, actionable system prompt, with NO header explainer, or footer debrief, ONLY return the raw system prompt, Dont even label it, only the instructions that sets role, tone, constraints. Use imperative, second person. No examples unless relevant. Verbose and explicit enhancements to the provided content to ensure high quality expansion of instruction set to match determined intention.";

    // Keep these to avoid breaking any assumptions elsewhere
    const sysgenPending = new Set();
    let isSysGenStreaming = false;
    let sysgenCurrentId = null;

    function toggleSystemEditor(forceOpen) {
      const wrap = el('systemEditorWrap'); if (!wrap) return;
      const toggleOut = el('systemToggleBtn');
      const toggleIn = el('systemToggleBtnInside');
      const show = forceOpen ?? wrap.classList.contains('hide'); // true = open
      if (show) {
        wrap.classList.remove('hide');
        if (toggleOut) toggleOut.classList.add('hide');
        if (toggleIn) toggleIn.classList.remove('hide');
      } else {
        wrap.classList.add('hide');
        if (toggleOut) toggleOut.classList.remove('hide');
        if (toggleIn) toggleIn.classList.add('hide');
      }
    }
    function setSysGenBusy(isBusy) {
      const b = el('sysGenBtn'); if (!b) return;
      b.disabled = !!isBusy;
      b.textContent = isBusy ? 'Generating…' : 'Generate';
    }

    function asHtml(html) {
      return { __html: String(html || '') };
    }


    const CONNECTING_HTML = asHtml(`<svg style="animation: spin 1s linear infinite;" width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3.51221C5.50442 4.74772 3 8.08143 3 12.0001C3 16.9707 7.02944 21.0001 12 21.0001C16.9706 21.0001 21 16.9707 21 12.0001C21 8.08143 18.4956 4.74772 15 3.51221" stroke="#ffaa00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`);


    const RECONNECTING_HTML = asHtml(`<svg style="animation: spin 1s linear infinite;" width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3.51221C5.50442 4.74772 3 8.08143 3 12.0001C3 16.9707 7.02944 21.0001 12 21.0001C16.9706 21.0001 21 16.9707 21 12.0001C21 8.08143 18.4956 4.74772 15 3.51221" stroke="#00aaff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`);

    const CHECK_HTML = asHtml(`<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M21 12C21 16.9706 16.9706 21 12 21M21 12C21 7.02944 16.9706 3 12 3M21 12C21 13.6569 16.9706 15 12 15C7.02944 15 3 13.6569 3 12M21 12C21 10.3431 16.9706 9 12 9C7.02944 9 3 10.3431 3 12M12 21C7.02944 21 3 16.9706 3 12M12 21C10.3431 21 9 16.9706 9 12C9 7.02944 10.3431 3 12 3M12 21C13.6569 21 15 16.9706 15 12C15 7.02944 13.6569 3 12 3M3 12C3 7.02944 7.02944 3 12 3" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`);


    function setConn(colorOrLabel, maybeLabel) {
      const dot = el('connDot'), text = el('connText');
      if (!dot || !text) return;

      // Parse args
      let color, label, labelProvided = false;
      if (arguments.length === 1) {
        if (colorOrLabel === 'red' || colorOrLabel === 'green' || colorOrLabel === 'blue') {
          color = colorOrLabel;
        } else {
          label = colorOrLabel;
          labelProvided = true;
        }
      } else if (arguments.length >= 2) {
        color = colorOrLabel;
        label = maybeLabel;
        labelProvided = true;
      }

      // Always reset dot color to neutral (removes any default 'conn-blue')
      dot.classList.remove('conn-red', 'conn-green', 'conn-blue');

      // Apply color only if explicitly provided
      if (color === 'green' || color === 'red' || color === 'blue') {
        dot.classList.add(color === 'green' ? 'conn-green'
          : color === 'red' ? 'conn-red'
            : 'conn-blue');
      }

      // Label: hidden by default unless provided
      if (!labelProvided) {
        text.textContent = '';
        text.classList.add('hide');
      } else {
        const isHtmlObj = label && typeof label === 'object' && typeof label.__html === 'string';
        const hasLabel =
          (typeof label === 'string' && label.trim().length) ||
          (isHtmlObj && label.__html.trim().length) ||
          (label instanceof Node);

        if (hasLabel) {
          text.classList.remove('hide');
          if (label instanceof Node) {
            text.innerHTML = '';
            text.appendChild(label);
          } else if (isHtmlObj) {
            text.innerHTML = label.__html; // trusted constants only
          } else {
            text.textContent = String(label);
          }
        } else {
          text.textContent = '';
          text.classList.add('hide');
        }
      }
    }


    function showModelDropdown(show) {
      const sel = el('modelSelect');
      if (!sel) return;
      sel.classList[show ? 'remove' : 'add']('hide');
      sel.disabled = !show;
    }

    // ─────────── Generic stream routing
    const ROUTES = new Map();          // reqId -> { sink:'chat'|'element', elId?, mode?, format?, lock? }
    const streamingElements = new Set(); // element ids being streamed into (to suppress autosaves)

    function resolveEl(elOrId) { return typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId; }
    function isTextControl(el) { return !!el && ('value' in el); }
    function lockElement(el, lock = true) {
      if (!el) return;
      if ('readOnly' in el) el.readOnly = !!lock;
      if ('disabled' in el && !('readOnly' in el)) el.disabled = !!lock;
      if (el.getAttribute && el.hasAttribute('contenteditable')) {
        el.setAttribute('data-was-contenteditable', el.getAttribute('contenteditable') || 'false');
        el.setAttribute('contenteditable', lock ? 'false' : (el.getAttribute('data-was-contenteditable') || 'true'));
      }
      el.setAttribute?.('aria-busy', lock ? 'true' : 'false');
    }
    function writeToElement(el, chunk, {
      mode = 'append',      // 'append' | 'replace'
      format = 'text',      // 'text' | 'markdown'
      scroll = true,
      caretToEnd = true
    } = {}) {
      if (!el) return;
      let prev = isTextControl(el) ? (el.value || '') : (el.innerText || el.textContent || '');
      let next = (mode === 'replace') ? chunk : (prev + chunk);

      if (isTextControl(el)) {
        el.value = next;
        if (caretToEnd) {
          try { el.selectionStart = el.selectionEnd = el.value.length; } catch { }
          el.scrollTop = el.scrollHeight;
        }
      } else {
        if (format === 'markdown') {
          el.innerHTML = mdToHtml(next);
          try { highlightIn(el); } catch { }
        } else {
          el.textContent = next;
        }
        if (scroll) {
          const container = el.closest('.chat') || el.parentElement;
          if (container && typeof container.scrollTop === 'number') container.scrollTop = container.scrollHeight;
        }
      }
    }
    function registerRoute(reqId, route) { ROUTES.set(reqId, route || { sink: 'chat' }); }
    function routeFor(id) { return ROUTES.get(id) || { sink: 'chat' }; }
    function clearRoute(id) { ROUTES.delete(id); }

    // ─────────── Outbox queue (send while connecting -> queue; flush on reconnect)
    const outbox = []; // [{ payload, route }]
    let isConnected = false, isConnecting = false;

    function requestLLM(payload, route) {
      const id = payload.id || newId('req');
      payload.id = id;
      registerRoute(id, route);

      if (!isConnected || !client) {
        outbox.push({ payload, route });
        if (route?.sink === 'element' && route.elId) {
          const n = el(route.elId);
          if (n && ('placeholder' in n)) {
            n.placeholder = (n.placeholder || '').startsWith('Queued…') ? n.placeholder : `Queued… ${n.placeholder || ''}`;
          }
        }
        return id;
      }
      try { client.send(HUB_ADDR, JSON.stringify(payload), { noReply: true, msgHoldingSeconds: 600 }); } catch { }
      return id;
    }

    function flushOutbox() {
      while (isConnected && client && outbox.length) {
        const { payload } = outbox.shift();
        const p = client.send(HUB_ADDR, JSON.stringify(payload), { noReply: true, msgHoldingSeconds: 600 });
        p && p.catch(err => {
          outbox.unshift({ payload, route: null });
          console.debug('[nkn.flush] send failed; will retry', err?.message || err);
          return;
        });
      }
    }



    // ─────────── NKN (robust MultiClient + your message contract)
    let client = null, myAddr = null;
    let HUB_ADDR = settings.hub || '';
    let HUB_KEY = (HUB_ADDR.split('.')[1] || '').toLowerCase();   // <— NEW

    const linkConnected = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 7H16C18.7614 7 21 9.23858 21 12C21 14.7614 18.7614 17 16 17H14M10 7H8C5.23858 7 3 9.23858 3 12C3 14.7614 5.23858 17 8 17H10M8 12H16" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`

    const linkDisconnected = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14 6C13.4477 6 13 6.44772 13 7C13 7.55228 13.4477 8 14 8V6ZM10 18C10.5523 18 11 17.5523 11 17C11 16.4477 10.5523 16 10 16V18ZM14 16C13.4477 16 13 16.4477 13 17C13 17.5523 13.4477 18 14 18V16ZM8 11C7.44772 11 7 11.4477 7 12C7 12.5523 7.44772 13 8 13V11ZM3.70711 2.29289C3.31658 1.90237 2.68342 1.90237 2.29289 2.29289C1.90237 2.68342 1.90237 3.31658 2.29289 3.70711L3.70711 2.29289ZM20.2929 21.7071C20.6834 22.0976 21.3166 22.0976 21.7071 21.7071C22.0976 21.3166 22.0976 20.6834 21.7071 20.2929L20.2929 21.7071ZM19.4115 14.0898C19.1224 14.5604 19.2696 15.1763 19.7402 15.4653C20.2108 15.7544 20.8266 15.6072 21.1157 15.1366L19.4115 14.0898ZM12 13C12.5523 13 13 12.5523 13 12C13 11.4477 12.5523 11 12 11V13ZM7.08376 7.08376L7.79087 6.37666L7.08376 7.08376ZM8 16C5.79086 16 4 14.2091 4 12H2C2 15.3137 4.68629 18 8 18V16ZM16 8C18.2091 8 20 9.79086 20 12H22C22 8.68629 19.3137 6 16 6V8ZM14 8H16V6H14V8ZM10 16H8V18H10V16ZM16 16H14V18H16V16ZM20 12C20 12.7678 19.7846 13.4823 19.4115 14.0898L21.1157 15.1366C21.6767 14.2232 22 13.1478 22 12H20ZM8 13H12V11H8V13ZM2.29289 3.70711L6.37666 7.79087L7.79087 6.37666L3.70711 2.29289L2.29289 3.70711ZM6.90166 6.10048C4.11245 6.61703 2 9.06076 2 12H4C4 10.0423 5.40739 8.41122 7.26586 8.06704L6.90166 6.10048ZM6.37666 7.79087L16.2091 17.6233L17.6233 16.2091L7.79087 6.37666L6.37666 7.79087ZM16.2091 17.6233L20.2929 21.7071L21.7071 20.2929L17.6233 16.2091L16.2091 17.6233ZM16.7341 15.933C16.4969 15.9769 16.2516 16 16 16V18C16.3743 18 16.7415 17.9656 17.0983 17.8995L16.7341 15.933Z" fill="#ff0000"/>
</svg>`

    const cloudUnknown = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.437 13C13.437 12 14.437 11.6046 14.437 10.5C14.437 9.39543 13.5416 8.5 12.437 8.5C11.5051 8.5 10.722 9.13739 10.5 10M12.437 16H12.447M8.4 19C5.41766 19 3 16.6044 3 13.6493C3 11.2001 4.8 8.9375 7.5 8.5C8.34694 6.48637 10.3514 5 12.6893 5C15.684 5 18.1317 7.32251 18.3 10.25C19.8893 10.9449 21 12.6503 21 14.4969C21 16.9839 18.9853 19 16.5 19L8.4 19Z" stroke="#ff0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
    const cloudCheck = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 13.2222L10.8462 15L15 11M8.4 19C5.41766 19 3 16.6044 3 13.6493C3 11.2001 4.8 8.9375 7.5 8.5C8.34694 6.48637 10.3514 5 12.6893 5C15.684 5 18.1317 7.32251 18.3 10.25C19.8893 10.9449 21 12.6503 21 14.4969C21 16.9839 18.9853 19 16.5 19L8.4 19Z" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
    const fingerPrintUnknown = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.89258 17.7897C6.9083 17.7633 6.92441 17.7369 6.9409 17.7107C8.14358 15.7988 8.8398 13.5379 8.8398 11.1034C8.8398 9.14189 10.4299 7.55176 12.3915 7.55176C14.353 7.55176 15.9431 9.14189 15.9431 11.1034C15.9431 12.0065 15.8816 12.8957 15.7626 13.7672M13.8825 19.8437C14.4257 18.7596 14.871 17.6179 15.2069 16.4309M18.6156 17.4359C19.1883 15.4236 19.4949 13.2993 19.4949 11.1033C19.4949 7.18026 16.3147 4 12.3916 4C11.0978 4 9.88477 4.34591 8.83997 4.9503M4.40039 14.9783C4.96924 13.8073 5.28831 12.4926 5.28831 11.1033C5.28831 9.8095 5.63422 8.59646 6.2386 7.55166M12.3915 11.1035C12.3915 14.2265 11.4958 17.1403 9.94727 19.6019" stroke="#ff0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`
    const fingerPrint = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.89258 17.7897C6.9083 17.7633 6.92441 17.7369 6.9409 17.7107C8.14358 15.7988 8.8398 13.5379 8.8398 11.1034C8.8398 9.14189 10.4299 7.55176 12.3915 7.55176C14.353 7.55176 15.9431 9.14189 15.9431 11.1034C15.9431 12.0065 15.8816 12.8957 15.7626 13.7672M13.8825 19.8437C14.4257 18.7596 14.871 17.6179 15.2069 16.4309M18.6156 17.4359C19.1883 15.4236 19.4949 13.2993 19.4949 11.1033C19.4949 7.18026 16.3147 4 12.3916 4C11.0978 4 9.88477 4.34591 8.83997 4.9503M4.40039 14.9783C4.96924 13.8073 5.28831 12.4926 5.28831 11.1033C5.28831 9.8095 5.63422 8.59646 6.2386 7.55166M12.3915 11.1035C12.3915 14.2265 11.4958 17.1403 9.94727 19.6019" stroke="#00ff00" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`

    const loadingLoop = `<svg style="animation: spin 1s linear infinite;" width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3.51221C5.50442 4.74772 3 8.08143 3 12.0001C3 16.9707 7.02944 21.0001 12 21.0001C16.9706 21.0001 21 16.9707 21 12.0001C21 8.08143 18.4956 4.74772 15 3.51221" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`

    function updateChips() {
      const hasHub = !!(HUB_ADDR && isNknAddr(HUB_ADDR));
      const hasMe = !!myAddr;

      el('hubChipIcon').innerHTML = hasHub ? cloudCheck : cloudUnknown;
      el('meChipIcon').innerHTML = hasMe ? fingerPrint : fingerPrintUnknown;
      el('linkIcon').innerHTML = (hasHub && hasMe) ? linkConnected : linkDisconnected;

      el('hubChip').innerHTML = hasHub ? short(HUB_ADDR) : loadingLoop;
      el('meChip').innerHTML = hasMe ? short(myAddr) : loadingLoop;

    }

    function trySend(addr, obj, opts = {}) {
      if (!client || !addr || !isConnected) return false;
      const payload = JSON.stringify(obj);
      // Mobile-friendly defaults; caller can override
      const sendOpts = { noReply: true, msgHoldingSeconds: 600, responseTimeout: 15000, ...opts };
      const p = client.send(addr, payload, sendOpts);
      if (p && typeof p.then === 'function') {
        p.catch(err => {
          console.debug('[nkn.send] transient send failed; will rely on outbox/reconnect', err?.message || err);
        });
      }
      return true;
    }

    // Streaming (ordered)
    const streams = new Map();
    let currentStreamId = null;
    let pendingStreamId = null;
    let isStreaming = false;
    const cancelledStreams = new Set();

    function startStream(id, onChunk) { streams.set(id, { next: 1, lastAck: 0, buffer: new Map(), onChunk }); }
    function handleChunk(id, seq, data) {
      if (cancelledStreams.has(id)) return;
      const st = streams.get(id); if (!st) return; st.buffer.set(seq, data);
      if (!isStreaming && currentStreamId === null && pendingStreamId === id) { setStopMode(id); }
      while (st.buffer.has(st.next)) { const part = st.buffer.get(st.next); st.buffer.delete(st.next); st.onChunk(part); st.next++; }
      sendAck(id, st.next - 1);
    }
    function sendAck(id, upto) {
      const st = streams.get(id); if (!st || upto <= st.lastAck) return;
      st.lastAck = upto;
      trySend(HUB_ADDR, { event: 'llm.ack', id, upto }, { noReply: true, maxHoldingSeconds: 120 });
    }
    function endStream(id) { streams.delete(id); cancelledStreams.delete(id); if (currentStreamId === id) currentStreamId = null; if (pendingStreamId === id) pendingStreamId = null; }

    // Models
    let modelsLoaded = false;
    let modelRevealTimer = null;
    let clearLabelTimer = null;
    let modelsRetryTimer = null;
    let modelsRetryBackoff = 800;        // grows up to MODELS_MAX_BACKOFF_MS
    const MODELS_MAX_BACKOFF_MS = 15000;

    let modelsInFlight = false;
    let availableModels = [];            // canonical, de-duped, normalized names

    // Correlation & observability
    let lastModelsReqId = null;          // 'models:<nonce>'
    let modelsLastSeenAt = 0;            // ms
    let modelsSeenThisSession = 0;       // count of successful updates this page load

    function setModelsUIState(ready) {
      const sel = el('modelSelect');
      const newBtn = el('newSessionBtn');
      if (sel) sel.disabled = !ready;
      if (newBtn) newBtn.disabled = !ready;
    }

    function isValidModelName(name) {
      if (!name || typeof name !== 'string') return false;
      const v = name.trim();
      if (!v) return false;
      // Disallow any placeholder labels you use
      const bad = [
        'Loading Models', 'Loading Models…',
        '— no models —', '— timed out fetching models —',
        '— no models (hub error) —'
      ];
      if (bad.some(b => v.startsWith(b))) return false;
      // Must exist in the loaded list
      return availableModels.includes(v);
    }

    function showModelsError(msg) {
      const sel = el('modelSelect'); if (!sel) return;
      sel.innerHTML = '';
      const opt = document.createElement('option');
      opt.textContent = msg || '— no models —';
      sel.appendChild(opt);

      modelsInFlight = false;
      modelsLoaded = false;
      availableModels = [];
      setModelsUIState(false);
      showModelDropdown(true);
    }

    function showModelsLoading() {
      const sel = el('modelSelect');
      if (!sel) return;
      sel.innerHTML = '<option>Loading Models…</option>';
      sel.disabled = true;
      showModelDropdown(true);
    }

    function requestModelsList(force = false) {
      if (!HUB_ADDR || !client || !isConnected) return;

      // Avoid spamming the hub unless forced or previous attempt cleared
      if (modelsInFlight && !force) return;

      modelsInFlight = true;
      const nonce = Date.now();
      lastModelsReqId = `models:${nonce}`;

      // Fire both routes; echoing id helps correlation
      trySend(HUB_ADDR, { event: 'llm.request', id: lastModelsReqId, api: 'list', stream: false });
      trySend(HUB_ADDR, { event: 'ctrl.request', op: 'models', id: lastModelsReqId });

      // Retry with capped backoff until we see any models response
      if (modelsRetryTimer) clearTimeout(modelsRetryTimer);
      modelsRetryTimer = setTimeout(() => {
        if (!modelsLoaded) {
          modelsInFlight = false;
          modelsRetryBackoff = Math.min(modelsRetryBackoff * 1.6, MODELS_MAX_BACKOFF_MS);
          requestModelsList(true);
        }
      }, modelsRetryBackoff);
    }


    function ensureModels() {
      // call after connect
      showModelsLoading();
      modelsInFlight = false;
      modelsLoaded = false;
      modelsRetryBackoff = 800;
      requestModelsList(true);
    }

    function populateModels(modelsLike) {
      const sel = el('modelSelect'); if (!sel) return;

      // Normalize: accept {models:[{model|name|digest|id|string}...]}, or bare array, or {data:{models:[...]}}
      const arr = (() => {
        const d = modelsLike;
        if (Array.isArray(d)) return d;
        if (d && typeof d === 'object') {
          if (Array.isArray(d.models)) return d.models;
          if (d.data && Array.isArray(d.data.models)) return d.data.models;
          if (Array.isArray(d.data)) return d.data;
        }
        return [];
      })();

      const names = Array.from(new Set(arr.map((m) => {
        if (!m) return '';
        if (typeof m === 'string') return m.trim();
        if (typeof m === 'object') return (m.model || m.name || m.id || m.digest || '').trim();
        return '';
      }).filter(Boolean)));

      // Update globals
      availableModels = names.slice();
      modelsLoaded = availableModels.length > 0;
      modelsLastSeenAt = Date.now();
      if (modelsLoaded) modelsSeenThisSession++;

      // Rebuild UI
      sel.innerHTML = '';
      if (modelsLoaded) {
        for (const name of availableModels) {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          sel.appendChild(opt);
        }
      } else {
        const opt = document.createElement('option');
        opt.textContent = '— no models —';
        sel.appendChild(opt);
      }

      setModelsUIState(modelsLoaded);

      // Restore remembered value only if valid
      const remembered = getSavedModel();
      if (remembered && isValidModelName(remembered)) {
        sel.value = remembered;
      } else if (modelsLoaded && sel.options.length) {
        sel.value = sel.options[0].value;
      }

      // Creating a session is only allowed when the selection is valid.
      sel.onchange = () => {
        const model = sel.value;
        if (isValidModelName(model)) {
          setSavedModel(model);
          createSessionForModel(model);
        } else if (availableModels[0]) {
          sel.value = availableModels[0];
        }
      };

      showModelDropdown(true);
    }


    // Build history for seeding (exclude 'system'; it's sent separately)
    function buildHistoryForSession(sess) { return (sess?.messages || []).map(m => ({ role: m.role, content: m.content })); }

    // Session control → hub
    function currentOptions() { return { temperature: settings.temperature, top_p: settings.top_p, seed: settings.seed, num_ctx: settings.num_ctx }; }
    function sendSessionOpen(s, seed) {
      if (!s || !HUB_ADDR) return;
      const payload = {
        event: 'session.open',
        sid: s.id,
        model: s.model || undefined,
        system: (s.system || ''),
        options: currentOptions()
      };
      if (seed) { payload.history = buildHistoryForSession(s); payload.replace = true; }
      trySend(HUB_ADDR, payload);
    }
    function sendSessionReset(sid) { if (!sid || !HUB_ADDR) return; trySend(HUB_ADDR, { event: 'session.reset', sid }); }

    // Heartbeat / reconnect
    const HEARTBEAT_MS = 5000;
    let hbTimer = null;
    let lastPongAt = 0;

    function startHeartbeat() {
      if (hbTimer) clearInterval(hbTimer);
      hbTimer = setInterval(() => {
        if (!HUB_ADDR) return;

        if (!client && !isConnecting) {
          setConn(RECONNECTING_HTML);
          connectNKN();
          return;
        }

        try { trySend(HUB_ADDR, { event: 'ctrl.ping', ts: Date.now() }, { noReply: true, maxHoldingSeconds: 120 }); } catch { }

        const stale = (Date.now() - lastPongAt) > HEARTBEAT_MS * 5;
        if (stale && !isConnecting) {
          setConn(RECONNECTING_HTML);
          try { client && client.close(); } catch { }
          client = null;
          isConnected = false;
          connectNKN();
        }
      }, HEARTBEAT_MS);
    }


    window.addEventListener('unhandledrejection', (e) => {
      const s = String(e.reason && e.reason.message || e.reason || '');
      if (/RTCDataChannel\.readyState|Message timeout|ConnectToNodeTimeoutError/i.test(s)) {
        e.preventDefault();
        console.debug('[nkn] suppressed transient send error:', s);
      }
    });

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        const stale = (Date.now() - lastPongAt) > HEARTBEAT_MS * 3;
        if ((!client || stale) && !isConnecting) connectNKN();
      }
    });

    // LTE-proven NKN connect: minimal, robust for 5G/CGNAT
    function connectNKN() {
      if (isConnecting) return;
      if (!isNknAddr(HUB_ADDR)) { openSettings(); return; }

      isConnecting = true;
      isConnected = false;
      updateChips();


      setConn(CONNECTING_HTML);

      try { if (client) { try { client.close(); } catch { } } } catch { }

      client = new nkn.MultiClient({
        seed: getOrCreateSeed(),
        identifier: 'web',         // per proven scheme
        numSubClients: 4,
        originalClient: true,

        // Mobile-friendly defaults
        responseTimeout: 15000,    // ACK waits longer on LTE
        msgHoldingSeconds: 600     // queue at nodes while briefly offline
      });

      client.onConnect(() => {
        isConnecting = false;
        isConnected = true;
        setConn(CHECK_HTML);
        myAddr = client.addr; updateChips();
        setConn(CHECK_HTML);
        lastPongAt = Date.now();
        startHeartbeat();

        // Let hub know we're up (fire-and-forget, long holding)
        trySend(HUB_ADDR, { event: 'announce' }, { noReply: true, msgHoldingSeconds: 600 });

        // Kick model load once per connect
        if (clearLabelTimer) clearTimeout(clearLabelTimer);
        if (modelRevealTimer) clearTimeout(modelRevealTimer);
        clearLabelTimer = setTimeout(() => {
          const t = el('connText'); if (t) void t.offsetWidth;
          modelRevealTimer = setTimeout(() => {
            showModelsLoading();
            modelsLoaded = false;
            modelsInFlight = false;
            availableModels = [];
            requestModelsList(true);
          }, 0);
        }, 10);

        const s = getSession();
        if (s) {
          setSavedModel(s.model || getSavedModel());
          sendSessionOpen(s, /*seed*/true);
        }

        flushOutbox();
      });

      // One message funnel; onInbound will filter to the configured hub
      client.on('message', onInbound);

      client.on('willreconnect', () => {
        isConnecting = false;
        isConnected = false;
        setConn(RECONNECTING_HTML);
      });
      client.on('connectFailed', () => {
        isConnecting = false;
        isConnected = false;
        setConn('red', 'Connect failed');
        setTimeout(connectNKN, 1200 + Math.random() * 600); // jittered retry
      });
      client.on('close', () => {
        isConnecting = false;
        isConnected = false;
        setConn('red', 'Disconnected');
        setTimeout(connectNKN, 1200 + Math.random() * 600);
      });
      client.on('error', () => {
        isConnecting = false;
        isConnected = false;
        setConn('red', 'Error');
        // Heartbeat loop will attempt reconnect when stale
      });

      window.addEventListener('beforeunload', () => { try { client && client.close(); } catch { } });
    }


    function decodePayload(payload) {
      const tryParse = (s) => {
        try { return JSON.parse(s); } catch { return null; }
      };
      try {
        // Uint8Array / ArrayBuffer / DataView
        if (payload instanceof Uint8Array) {
          const s = new TextDecoder().decode(payload);
          const obj = tryParse(s);
          return obj || { raw: s };
        }
        if (payload instanceof ArrayBuffer) {
          const s = new TextDecoder().decode(new Uint8Array(payload));
          const obj = tryParse(s);
          return obj || { raw: s };
        }
        if (payload instanceof DataView) {
          const u8 = new Uint8Array(payload.buffer, payload.byteOffset, payload.byteLength);
          const s = new TextDecoder().decode(u8);
          const obj = tryParse(s);
          return obj || { raw: s };
        }

        if (typeof payload === 'string') {
          // Handle double-JSON (some bridges serialize twice)
          const once = tryParse(payload);
          if (!once) return null;
          if (typeof once === 'string') {
            const twice = tryParse(once);
            return twice || { raw: once };
          }
          return once;
        }

        if (payload && typeof payload === 'object') {
          // Some bridges wrap as { payload: "<json-string>" }
          if (typeof payload.payload === 'string') {
            const inner = tryParse(payload.payload);
            if (inner) return inner;
          }
          return payload;
        }
      } catch { }
      return null;
    }

    function onInbound(a, b) {
      try {
        let src, raw;
        if (a && typeof a === 'object' && (a.payload !== undefined || a.data !== undefined || a.src !== undefined)) {
          src = a.src || a.from || '';
          raw = a.payload ?? a.data;
        } else {
          src = a;
          raw = b;
        }

        const body = decodePayload(raw);
        if (!body || typeof body !== 'object') return;

        const ev = body.event || '';
        const srcStr = String(src || '');
        const fromKey = (srcStr.split('.')[1] || '').toLowerCase();

        // Robust acceptance:
        // - Prefer hub public key match if we have it
        // - Otherwise accept trusted families ('ctrl.', 'llm.', 'session.')
        const isTrustedFamily = /^ctrl\.|^llm\.|^session\./.test(ev);
        if (HUB_KEY && fromKey && fromKey !== HUB_KEY && isTrustedFamily) {
          // Log once per minute if mismatched to help diagnose
          if (!onInbound._lastKeyWarnAt || Date.now() - onInbound._lastKeyWarnAt > 60000) {
            console.warn('[inbound] src key mismatch; accepting due to trusted event family', { ev, src: srcStr, expectedKey: HUB_KEY });
            onInbound._lastKeyWarnAt = Date.now();
          }
        } else if (HUB_KEY && fromKey && fromKey !== HUB_KEY) {
          return;
        }

        // Heartbeat pong (+ nudge models if still not loaded)
        if (ev === 'ctrl.pong') {
          lastPongAt = Date.now();
          setConn('green', '');
          if (!modelsLoaded && !modelsInFlight) requestModelsList(true);
          return;
        }

        // MODELS (handle multiple shapes, correlate id, and stop retries)
        if (
          ev === 'llm.models' ||
          (ev === 'llm.result' && body.id && String(body.id).startsWith('models'))
        ) {
          // Stop retry loop
          modelsInFlight = false;
          if (modelsRetryTimer) clearTimeout(modelsRetryTimer);
          modelsRetryBackoff = 800;

          // Accept: body.data.models, body.models, or body.data
          const payload = (body && body.data) ? body.data : body;
          populateModels(payload);

          // If still empty, keep UI visible but disabled
          return;
        }

        // Noisy / informative only
        if (ev === 'session.ready' || ev === 'session.info' || ev === 'ctrl.info') return;
        if (ev === 'ctrl.error') {
          console.warn('[ctrl.error]', body);
          return;
        }

        // Route-aware handling for streams/results/errors
        const route = routeFor(body.id);

        if (ev === 'llm.start') {
          const { id, stream } = body;

          if (route.sink === 'element') {
            const elx = resolveEl(route.elId);
            if (route.lock) lockElement(elx, true);
            if (route.elId) streamingElements.add(route.elId);
            isSysGenStreaming = true; sysgenCurrentId = id;

            pendingStreamId = id;
            setStopMode(id);

            let first = true;
            startStream(id, (part) => {
              const t = extractDelta(part);
              if (!t) return;
              writeToElement(elx, t, {
                mode: first && route.mode === 'replace' ? 'replace' : 'append',
                format: route.format || 'text',
                scroll: true,
                caretToEnd: true
              });
              first = false;
            });
            return;
          }

          if (stream) {
            pendingStreamId = id;
            addStreamingAssistantBubble();
            const sess = getSession(); if (!sess) return;
            sess.messages.push({ role: 'assistant', content: '', ts: Date.now() });
            saveJSON(STORAGE.SESS, sessions);
            let acc = '';
            startStream(id, (part) => {
              const text = extractDelta(part);
              if (text) { acc += text; setStreamingContent(acc); updateLastAssistantContent(sess.id, acc); }
            });
          }
          return;
        }

        if (ev === 'llm.chunk') { handleChunk(body.id, body.seq, body.data); return; }

        if (ev === 'llm.done') {
          sendAck(body.id, body.last_seq);
          endStream(body.id);

          if (route.sink === 'element') {
            const elx = resolveEl(route.elId);
            lockElement(elx, false);
            if (route.elId) streamingElements.delete(route.elId);

            if (route.elId === 'systemMsg') {
              const s = getSession();
              if (s) {
                s.system = (el('systemMsg').value || '');
                saveJSON(STORAGE.SESS, sessions);
                sendSessionOpen(s, /*seed*/false);
              }
              setSysGenBusy(false);
              isSysGenStreaming = false; sysgenCurrentId = null;
              sysgenPending.delete(body.id);
            }

            setSendMode();
            clearRoute(body.id);
            return;
          }

          finishStreamingBubble();
          setSendMode();
          clearRoute(body.id);
          return;
        }

        if (ev === 'llm.result') {
          if (route.sink === 'element') {
            const elx = resolveEl(route.elId);
            const text = extractFull(body.data) || '';
            writeToElement(elx, text, { mode: route.mode || 'replace', format: route.format || 'text' });
            lockElement(elx, false);
            if (route.elId) streamingElements.delete(route.elId);

            if (route.elId === 'systemMsg') {
              const s = getSession();
              if (s) {
                s.system = (el('systemMsg').value || '');
                saveJSON(STORAGE.SESS, sessions);
                sendSessionOpen(s, /*seed*/false);
              }
              setSysGenBusy(false);
              sysgenPending.delete(body.id);
            }
            isSysGenStreaming = false; sysgenCurrentId = null;
            clearRoute(body.id);
            return;
          }
          const sess = getSession(); if (!sess) return;
          const text = extractFull(body.data);
          appendMessage(sess.id, 'assistant', text);
          renderChat();
          clearRoute(body.id);
          return;
        }

        if (ev === 'llm.error') {
          if (body.kind === 'models' || (body.id && String(body.id).startsWith('models'))) {
            modelsInFlight = false;
            modelsLoaded = false;
            if (modelsRetryTimer) clearTimeout(modelsRetryTimer);
            showModelsError('— no models (hub error) —');
            return;
          }

          if (route.sink === 'element') {
            const elx = resolveEl(route.elId);
            lockElement(elx, false);
            if (route.elId) streamingElements.delete(route.elId);
            setSysGenBusy(false);
            isSysGenStreaming = false; sysgenCurrentId = null;
            sysgenPending.delete(body.id);
            clearRoute(body.id);
            alert('[LLM Error] ' + (body.message || 'Error'));
            return;
          }
          const sess = getSession(); if (!sess) return;
          appendMessage(sess.id, 'assistant', '[error] ' + body.message);
          renderChat();
          setSendMode();
          clearRoute(body.id);
          return;
        }
      } catch (err) {
        console.warn('[onInbound] swallowed error', err);
      }
    }



    function extractDelta(part) {
      if (part?.message?.content) return part.message.content;
      if (typeof part?.response === 'string') return part.response;
      return '';
    }
    function extractFull(obj) {
      if (obj?.message?.content) return obj.message.content;
      if (typeof obj?.response === 'string') return obj.response;
      try { return JSON.stringify(obj); } catch { return String(obj); }
    }

    // Compose & send (DELTA MODE) — uses router with default 'chat' sink (queue-aware)
    function sendPrompt() {
      const s = getSession(); if (!s) { alert('Choose a model first.'); return; }
      const text = el('prompt').value; if (!text.trim()) return;

      appendMessage(s.id, 'user', text.trim()); renderChat(); el('prompt').value = '';

      const reqId = newId('req');
      const doStream = !!settings.stream;

      requestLLM({
        event: 'llm.request',
        id: reqId,
        api: 'chat',
        sid: s.id,
        delta: text.trim(),
        stream: doStream,
        kwargs: { options: currentOptions() }
      }, {
        sink: 'chat'
      });
    }

    const playSign = `<svg width="32px" height="32px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M16.6582 9.28638C18.098 10.1862 18.8178 10.6361 19.0647 11.2122C19.2803 11.7152 19.2803 12.2847 19.0647 12.7878C18.8178 13.3638 18.098 13.8137 16.6582 14.7136L9.896 18.94C8.29805 19.9387 7.49907 20.4381 6.83973 20.385C6.26501 20.3388 5.73818 20.0469 5.3944 19.584C5 19.053 5 18.1108 5 16.2264V7.77357C5 5.88919 5 4.94701 5.3944 4.41598C5.73818 3.9531 6.26501 3.66111 6.83973 3.6149C7.49907 3.5619 8.29805 4.06126 9.896 5.05998L16.6582 9.28638Z" stroke="#ffffff" stroke-width="2" stroke-linejoin="round"/>
</svg>`;
    const stopSign = `<svg width="32px" height="32px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="4" y="4" width="16" height="16" rx="2" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;

    // Stop button behavior
    function setStopMode(id) {
      const btn = el('sendBtn');
      currentStreamId = id;
      isStreaming = true;
      btn.innerHTML = stopSign;  // use innerHTML to render the SVG
      btn.onclick = stopGeneration;
    }
    function setSendMode() {
      const btn = el('sendBtn');
      isStreaming = false;
      pendingStreamId = null;
      currentStreamId = null;
      btn.innerHTML = playSign;
      btn.onclick = sendPrompt;
    }
    function stopGeneration() {
      if (!currentStreamId || !HUB_ADDR) { setSendMode(); return; }
      cancelledStreams.add(currentStreamId);
      trySend(HUB_ADDR, { event: 'llm.cancel', id: currentStreamId }, { noReply: true, maxHoldingSeconds: 120 });
      setSendMode();
    }


    // System editor → persist locally and push to hub (suppressed while streaming to this element)
    el('systemMsg').addEventListener('input', debounce(() => {
      if (streamingElements.has('systemMsg')) return; // suppress while generator streams
      const s = getSession(); if (!s) return;
      s.system = el('systemMsg').value;
      saveJSON(STORAGE.SESS, sessions);
      sendSessionOpen(s, /*seed*/false);
    }, 250));

    // Settings modal
    function openSettings() { updateSettingsUI(); el('overlay').style.display = 'flex'; }
    function closeSettings() { el('overlay').style.display = 'none'; }

    // Sidebar Toggle Mobile
    function toggleSidebar() {
      const elx = document.getElementById('sidebar');
      const elxb = document.getElementById('backdrop');
      if (!elx) return;
      const curLeft = getComputedStyle(elx).left.trim();
      elx.style.left = (curLeft === '0px' || curLeft === '0%') ? '-50%' : '0%';
      elxb.style.left = (curLeft === '0px' || curLeft === '0%') ? '-100%' : '0%';
    }

    // Boot
    function boot() {
      setConn(); // clears blue & hides label

      // Move the model select next to status + keep it hidden until we truly have models
      (() => {
        const row = el('statusRow'), sel = el('modelSelect');
        if (row && sel && sel.parentElement !== row) row.appendChild(sel);
        showModelDropdown(false); // hide until models list arrives
      })();

      // System Message toggle + actions
      el('systemToggleBtn').onclick = () => toggleSystemEditor();
      el('systemToggleBtnInside').onclick = () => toggleSystemEditor();

      // System Prompt Generate (streams back into the textarea)
      el('sysGenBtn').onclick = () => {
        const s = getSession(); if (!s) { alert('Create/select a session first.'); return; }
        if (!HUB_ADDR) { openSettings(); return; }
        if (!modelsLoaded) { alert('Models are not loaded yet. Please wait.'); return; }

        const ta = el('systemMsg');
        const userDesc = (ta.value || '').trim();
        if (!userDesc) { alert('Type what you want your system prompt to do, then click Generate.'); return; }

        const model = getCurrentModel();
        if (!model || el('modelSelect').disabled) { alert('Choose a model first, then try Generate again.'); return; }

        const genId = newId('sysgen');

        // messages-mode payload — note: NO sid here
        const payload = {
          event: 'llm.request',
          id: genId,
          api: 'chat',
          model,
          stream: true,
          messages: [
            { role: 'system', content: SYSTEM_GEN_PROMPT },
            { role: 'user', content: userDesc }
          ],
          kwargs: { options: currentOptions() },
          aux: 'sysgen'
        };

        // route the stream into the textarea
        const route = {
          sink: 'element',
          elId: 'systemMsg',
          mode: 'replace',  // first token replaces; subsequent chunks append
          format: 'text',
          lock: true
        };

        // UI state
        sysgenPending.add(genId);
        setSysGenBusy(true);
        streamingElements.add('systemMsg');
        lockElement(ta, true);

        // Send (queue-aware)
        requestLLM(payload, route);
      };

      el('sysSaveBtn').onclick = () => {
        const s = getSession();
        if (!s) { alert('Create/select a session first.'); return; }
        s.system = el('systemMsg').value || '';
        saveJSON(STORAGE.SESS, sessions);
        sendSessionOpen(s, /*seed*/false);
      };

      // Apply hub from URL before anything else that depends on it
      applyHubFromUrl();

      renderSessions(); renderSystemEditor(); renderChat(); updateSettingsUI();

      // Ensure HUB_ADDR reflects (possibly updated) settings.hub
      HUB_ADDR = settings.hub || '';
      HUB_KEY = (HUB_ADDR.split('.')[1] || '').toLowerCase();  // <— NEW
      updateChips();

      // Wire inputs
      el('sendBtn').onclick = sendPrompt;
      el('prompt').addEventListener('keydown', e => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendPrompt();
        }
      });
      el('settingsBtn').onclick = openSettings;
      el('closeModal').onclick = closeSettings;
      el('saveSettings').onclick = () => { if (saveSettingsFromUI()) { closeSettings(); } };

      // NEW: reset local NKN key and reconnect (no full reload needed)
      (() => {
        const btn = el('resetKeyBtn');
        if (!btn) return;
        btn.onclick = () => {
          if (!confirm('Reset your local NKN key? A new keypair will be generated and the client will reconnect.')) return;
          localStorage.removeItem(STORAGE.SEED);
          try { client && client.close && client.close(); } catch { }
          client = null;
          myAddr = null;
          updateChips();
          setConn(RECONNECTING_HTML);
          connectNKN();
        };
      })();


      // Disallow creating a session until models have actually loaded
      const newBtn = el('newSessionBtn');
      if (newBtn) {
        newBtn.disabled = true; // start disabled
        newBtn.onclick = () => {
          const sel = el('modelSelect');
          const model = sel && sel.value;
          if (!modelsLoaded || !model || sel.disabled || /loading|no models/i.test(String(sel.options[0]?.text || ''))) {
            alert('Models are not ready yet. Please wait for the list to load.');
            return;
          }
          createSessionForModel(model);
        };
      }

      // Also protect the model select itself until ready
      const modelSel = el('modelSelect');
      if (modelSel) {
        modelSel.disabled = true;     // will be enabled when populateModels() runs
        modelSel.classList.add('hide');
      }

      // Keep existing session selection behavior
      if (activeSessionId) setActiveSession(activeSessionId);

      // Kick off NKN connect; onConnect() will show "Loading…" and invoke ensureModels()
      connectNKN();
    }
    boot();

  </script>


</body>

</html>
